1
00:00:22,600 --> 00:00:24,660
欢迎回来

2
00:00:24,810 --> 00:00:27,570
我们今天

3
00:00:27,690 --> 00:00:30,250
来继续讨论支持向量机

4
00:00:30,370 --> 00:00:31,260
具体地

5
00:00:31,390 --> 00:00:33,400
我想先讲一下最优间隔分类器

6
00:00:33,520 --> 00:00:35,520
之后我们岔开主题

7
00:00:35,610 --> 00:00:37,450
讲一下原始优化问题和对偶优化问题

8
00:00:37,570 --> 00:00:39,020
特别地要讲一下

9
00:00:39,130 --> 00:00:40,970
KKT条件

10
00:00:41,080 --> 00:00:43,900
之后我们导出

11
00:00:44,020 --> 00:00:46,100
之前提出问题的对偶问题

12
00:00:46,210 --> 00:00:49,080
这会帮我们引出关于核方法的讨论

13
00:00:49,180 --> 00:00:50,390
在这上面

14
00:00:50,490 --> 00:00:52,850
我可能只会花一点时间

15
00:00:52,960 --> 00:00:55,620
而且很有可能是在下一讲中进行

16
00:00:55,720 --> 00:00:59,210
今天的课上

17
00:00:59,290 --> 00:01:01,650
我会花一些时间讲优化问题

18
00:01:01,740 --> 00:01:05,460
由于时间问题

19
00:01:05,550 --> 00:01:08,280
我不会讲的太详细

20
00:01:08,380 --> 00:01:10,660
我会讲到凸优化问题

21
00:01:10,780 --> 00:01:12,490
但是不准备详细展开

22
00:01:12,600 --> 00:01:15,030
在这周的讨论课上

23
00:01:15,140 --> 00:01:18,040
助教会用更多的时间

24
00:01:18,130 --> 00:01:19,950
来讲解

25
00:01:20,050 --> 00:01:21,730
凸优化问题--

26
00:01:21,850 --> 00:01:24,650
一种非常漂亮而且有用的理论

27
00:01:24,750 --> 00:01:26,640
如果你们想了解的更多

28
00:01:26,750 --> 00:01:29,520
欢迎参加周五的讨论课

29
00:01:29,630 --> 00:01:35,590
回顾一下我们之前讲过的内容

30
00:01:35,690 --> 00:01:41,030
上节课我们通过一些知识

31
00:01:41,130 --> 00:01:42,390
开始引出支持向量机

32
00:01:42,470 --> 00:01:46,200
我们将假设表示成

33
00:01:46,300 --> 00:01:50,210
这样的形式

34
00:01:50,280 --> 00:02:05,340
g取+1或-1

35
00:02:05,440 --> 00:02:07,770
取决于z是否大于0

36
00:02:07,890 --> 00:02:11,190
我讲过为了方便地引出

37
00:02:11,280 --> 00:02:13,250
对SVM的讨论  我们会用--

38
00:02:13,360 --> 00:02:16,400
我们会改变原有的约定  用+1

39
00:02:16,480 --> 00:02:21,000
和-1表示类标签 最后

40
00:02:21,080 --> 00:02:26,650
我们讲了函数间隔

41
00:02:26,730 --> 00:02:28,830
表示为γ ?^((i) )

42
00:02:28,930 --> 00:02:37,930
我们的直观理解是

43
00:02:38,020 --> 00:02:41,560
如果函数间隔是一个很大正数

44
00:02:41,640 --> 00:02:44,380
这意味着我们的分类

45
00:02:44,480 --> 00:02:46,430
是正确而且足够确定的

46
00:02:46,540 --> 00:02:49,250
所以当y^((i) )=+1时

47
00:02:49,340 --> 00:02:53,090
我们希望w^T x^((i) )+b尽量大

48
00:02:53,170 --> 00:02:56,310
如果y^((i) )=-1

49
00:02:56,400 --> 00:02:58,910
那么这时我们希望w^T x^((i) )+b

50
00:02:59,000 --> 00:03:00,180
是一个尽量小的负数

51
00:03:00,290 --> 00:03:01,950
这样总体上  我们希望函数间隔尽量大

52
00:03:02,040 --> 00:03:04,730
我们还讲过  函数间隔

53
00:03:04,850 --> 00:03:05,800
是一种奇怪的属性

54
00:03:05,920 --> 00:03:08,630
你可以通过

55
00:03:08,720 --> 00:03:10,870
对参数w  b进行加倍的方式

56
00:03:10,960 --> 00:03:12,760
增加函数间隔

57
00:03:12,880 --> 00:03:19,880
所以之后我们定义了几何间隔

58
00:03:19,980 --> 00:03:34,760
实际上  它等于

59
00:03:34,870 --> 00:03:39,330
函数间隔除以||w||

60
00:03:39,440 --> 00:03:42,210
几何间隔的含义

61
00:03:42,320 --> 00:03:45,080
可以这样解释

62
00:03:45,190 --> 00:03:47,260
我来举一些例子

63
00:03:47,380 --> 00:03:50,920
例如:在这个图中

64
00:03:51,030 --> 00:03:54,040
几何间隔表示的是一个训练样本

65
00:03:54,140 --> 00:03:55,760
和超平面之间的举例

66
00:03:55,870 --> 00:03:58,460
它实际上是一个有符号的距离

67
00:03:58,560 --> 00:04:00,150
如果你的分类是正确的

68
00:04:00,260 --> 00:04:02,400
那么这个样本的距离就是正的

69
00:04:02,510 --> 00:04:04,370
如果某个样本的分类是错误的

70
00:04:04,490 --> 00:04:07,640
那么几何间隔就会是

71
00:04:07,760 --> 00:04:09,720
这个点到分割线的几何距离的负值

72
00:04:09,850 --> 00:04:11,740
你有一个用于分隔样本的超平面

73
00:04:11,830 --> 00:04:14,040
该平面由

74
00:04:14,120 --> 00:04:18,260
w^T x+b=0定义

75
00:04:18,370 --> 00:04:28,810
哦  我还定义了

76
00:04:28,920 --> 00:04:34,790
这些概念

77
00:04:34,880 --> 00:04:36,010
也就是相对于整个训练

78
00:04:36,010 --> 00:04:37,360
集合的函数间隔和几何间隔

79
00:04:37,460 --> 00:04:39,430
我们将其定义成最坏形式

80
00:04:39,520 --> 00:04:40,420
也就是最小的相对于单个

81
00:04:40,420 --> 00:04:41,400
样本的函数间隔或几何间隔

82
00:04:41,520 --> 00:04:49,550
在我们讲解

83
00:04:49,660 --> 00:04:51,720
最优间隔分类器的时候

84
00:04:51,830 --> 00:04:55,350
我们讲过  学习算法会选取参数w和b

85
00:04:55,460 --> 00:04:57,710
使得几何间隔最大化

86
00:04:57,820 --> 00:05:00,260
所以我们的目标是找到一个超平面

87
00:05:00,350 --> 00:05:02,160
在将正负样本分开的同时

88
00:05:02,290 --> 00:05:05,100
使平面的到正负样本间的距离

89
00:05:05,210 --> 00:05:07,580
尽可能的大

90
00:05:07,680 --> 00:05:12,880
如果你们选择参数w和b

91
00:05:12,960 --> 00:05:14,780
使得几何间隔最大化

92
00:05:14,870 --> 00:05:17,060
一个特殊的性质是

93
00:05:17,160 --> 00:05:21,020
你可以任意地按比例缩放w和b

94
00:05:21,120 --> 00:05:23,560
你可以看一下几何间隔的定义

95
00:05:23,670 --> 00:05:29,180
我可以选择将参数w和b放大为原来的2倍

96
00:05:29,280 --> 00:05:30,650
10倍或任意倍数

97
00:05:30,760 --> 00:05:34,570
这都不会改变几何间隔

98
00:05:34,670 --> 00:05:37,460
关于这个性质的一种解释是

99
00:05:37,550 --> 00:05:40,590
如果你看一下这个超平面

100
00:05:40,680 --> 00:05:42,480
你可以看到这条线

101
00:05:42,600 --> 00:05:44,060
分隔了正负样本

102
00:05:44,170 --> 00:05:46,270
如果同时按比例缩放w和b

103
00:05:46,380 --> 00:05:49,190
都不会改变这个平面的位置

104
00:05:49,290 --> 00:05:52,270
因为方程:w^T x+b=0

105
00:05:52,360 --> 00:05:56,420
和方程2w^T x+2b=0是等价的

106
00:05:56,520 --> 00:05:57,920
因此我们得到的是相同的直线

107
00:05:58,000 --> 00:06:00,010
这意味着

108
00:06:00,100 --> 00:06:04,000
为了方便  我们可以按任意比例缩放w和b

109
00:06:04,110 --> 00:06:05,720
而不会改变结果

110
00:06:05,830 --> 00:06:08,920
例如  我可以

111
00:06:09,020 --> 00:06:11,240
添加这样的约束

112
00:06:11,360 --> 00:06:14,900
使得||w||=1  这意味着

113
00:06:14,970 --> 00:06:17,070
你可以先求出w和b的解

114
00:06:17,180 --> 00:06:18,870
之后通过重新缩放这些参数

115
00:06:18,960 --> 00:06:20,690
你可以轻易地满足这个条件

116
00:06:20,800 --> 00:06:22,830
这个条件使的w的模变为了1

117
00:06:22,950 --> 00:06:24,850
所以我可以添加这样的条件

118
00:06:24,960 --> 00:06:26,710
实际上并不会改变问题

119
00:06:26,830 --> 00:06:29,460
或者我可以添加其它条件

120
00:06:29,560 --> 00:06:33,000
例如我可以加入一个条件

121
00:06:33,090 --> 00:06:37,000
使|w_1 |=1

122
00:06:37,090 --> 00:06:38,380
我现在可以只取

123
00:06:38,480 --> 00:06:39,850
其中的一个条件  而不必是全部的条件

124
00:06:39,960 --> 00:06:41,720
这个条件限制

125
00:06:41,800 --> 00:06:44,120
w的第一个元素的绝对值为1

126
00:06:44,210 --> 00:06:46,480
你可以通过对找到的w进行重新缩放

127
00:06:46,600 --> 00:06:48,730
来满足这个条件

128
00:06:48,850 --> 00:06:51,460
除此之外  还可以有

129
00:06:51,570 --> 00:06:56,700
其他一些奇怪的条件  例如这样的条件

130
00:06:56,810 --> 00:06:58,420
再一次地  你可以

131
00:06:58,520 --> 00:07:00,610
通过求解最优间隔

132
00:07:00,690 --> 00:07:03,950
之后再向上或向下缩放w

133
00:07:04,040 --> 00:07:05,640
这样  你就可以保证

134
00:07:05,740 --> 00:07:06,920
满足这个条件

135
00:07:07,040 --> 00:07:09,500
再说一次

136
00:07:09,600 --> 00:07:10,710
我们只考虑满足其中的一个条件

137
00:07:10,790 --> 00:07:11,750
而不是全部条件

138
00:07:11,850 --> 00:07:16,730
我们可以自由地选择

139
00:07:16,840 --> 00:07:19,000
缩放因子  这一点将带来很大的便利

140
00:07:19,120 --> 00:07:22,200
之后我们会看到这一点 好的

141
00:07:22,310 --> 00:07:26,200
让我们继续开始解决优化问题

142
00:07:26,320 --> 00:07:29,620
我的目标是选取w  b

143
00:07:29,730 --> 00:07:32,690
以使得几何间隔最大化

144
00:07:32,800 --> 00:07:35,840
这是我对这个优化问题的

145
00:07:35,920 --> 00:07:37,160
第一种写法

146
00:07:37,300 --> 00:07:40,380
实际上这就是我在上节课

147
00:07:40,490 --> 00:07:41,960
最后写出的形式

148
00:07:42,070 --> 00:07:43,590
求解参数

149
00:07:43,700 --> 00:07:46,930
γ  w和b使得

150
00:07:47,040 --> 00:07:58,710
这些条件成立

151
00:07:58,820 --> 00:08:04,270
这里我选择添加了这个标准化条件

152
00:08:04,390 --> 00:08:08,010
所以w的模

153
00:08:08,100 --> 00:08:11,890
应该等于1  这使得

154
00:08:12,010 --> 00:08:14,310
几何间隔等于函数间隔

155
00:08:14,420 --> 00:08:17,220
所以我的意思是  我需要找到一个

156
00:08:17,330 --> 00:08:20,800
γ  使其值尽可能大

157
00:08:20,900 --> 00:08:24,240
并且所有训练样本

158
00:08:24,320 --> 00:08:27,880
的集合间隔都大于或等于γ

159
00:08:27,960 --> 00:08:32,700
而这个||w||=1的条件

160
00:08:32,800 --> 00:08:35,240
保证了函数间隔

161
00:08:35,330 --> 00:08:37,100
等于几何间隔

162
00:08:37,200 --> 00:08:40,190
要找到一个γ使得

163
00:08:40,280 --> 00:08:42,400
所有几何间隔

164
00:08:42,520 --> 00:08:44,100
都要大于等于γ

165
00:08:44,200 --> 00:08:48,290
求解了这个最优化问题之后

166
00:08:48,420 --> 00:08:54,240
你就可以得到最优间隔分类器--

167
00:08:54,360 --> 00:08:58,640
这并不是一个非常好的优化问题

168
00:08:58,760 --> 00:09:01,770
因为这个约束是一个非常糟糕的非凸性约束

169
00:09:01,870 --> 00:09:04,620
实际上  你要求解的

170
00:09:04,710 --> 00:09:09,100
参数w  位于

171
00:09:09,170 --> 00:09:11,580
一个球体的表面上

172
00:09:11,700 --> 00:09:14,100
它位于一个圆形或球体上

173
00:09:14,230 --> 00:09:18,960
如果我们得到一个

174
00:09:19,080 --> 00:09:20,550
凸优化问题

175
00:09:20,660 --> 00:09:22,350
我们必须要保证

176
00:09:22,460 --> 00:09:24,070
诸如梯度下降算法这样的局部最优值搜索算法

177
00:09:24,160 --> 00:09:26,030
不会找到局部最优值

178
00:09:26,140 --> 00:09:28,420
事实证明这个约束

179
00:09:28,530 --> 00:09:29,910
是一个非凸性约束

180
00:09:29,980 --> 00:09:32,300
它是一个非常糟糕的约束

181
00:09:32,450 --> 00:09:33,580
我们一定要避免

182
00:09:33,700 --> 00:09:42,210
所以我们需要改变优化问题

183
00:09:42,300 --> 00:09:52,460
的表述方式 现在  让我

184
00:09:52,580 --> 00:09:54,850
提出一个稍微不同的最优化问题

185
00:09:54,950 --> 00:09:59,670
让我们使函数间隔除以

186
00:09:59,760 --> 00:10:07,280
||w||的值最大化  同时满足这样的条件

187
00:10:07,380 --> 00:10:14,490
换句话说  一旦你找到了一个

188
00:10:14,550 --> 00:10:18,230
γ ?  那么每一个

189
00:10:18,300 --> 00:10:21,160
训练样本的函数间隔

190
00:10:21,260 --> 00:10:22,660
都会大于等于γ ?

191
00:10:22,770 --> 00:10:24,350
我的最优化目标是

192
00:10:24,440 --> 00:10:26,560
我希望使γ ?/(||w||)的值

193
00:10:26,650 --> 00:10:27,950
最大化

194
00:10:28,060 --> 00:10:31,260
也就是说我希望函数间隔

195
00:10:31,310 --> 00:10:32,750
除以||w||的值最大化

196
00:10:32,850 --> 00:10:36,230
记得我们之前讲过

197
00:10:36,350 --> 00:10:39,580
函数间隔除以||w||就等于几何间隔

198
00:10:39,680 --> 00:10:41,350
所以这只是对同样的优化问题

199
00:10:41,460 --> 00:10:43,430
的另外一种表述形式

200
00:10:43,540 --> 00:10:46,030
虽然这样的方式有点令人困惑

201
00:10:46,130 --> 00:10:47,990
有问题吗?

202
00:10:48,110 --> 00:10:53,990
第二种表述方法中

203
00:10:54,100 --> 00:10:56,870
写的是函数间隔除以||w||

204
00:10:56,980 --> 00:10:59,950
为什么不直接写几何间隔呢?

205
00:11:00,060 --> 00:11:01,810
为什么不--

206
00:11:01,930 --> 00:11:04,990
你能再说一遍吗?

207
00:11:05,110 --> 00:11:05,970
第二种表述方法中

208
00:11:06,090 --> 00:11:07,260
我们的目标是最大化

209
00:11:07,350 --> 00:11:08,470
函数间隔除以||w||的值

210
00:11:08,590 --> 00:11:10,230
哦  我看到了 是的

211
00:11:10,410 --> 00:11:12,150
【听不清】

212
00:11:12,270 --> 00:11:13,850
让我看看

213
00:11:13,960 --> 00:11:15,350
这是函数间隔  对吗?

214
00:11:15,460 --> 00:11:16,720
它不是几何间隔

215
00:11:16,840 --> 00:11:17,710
是的

216
00:11:17,830 --> 00:11:18,990
哦

217
00:11:19,110 --> 00:11:21,730
我希望在我的优化目标上

218
00:11:21,840 --> 00:11:23,000
除以||w||

219
00:11:23,100 --> 00:11:25,360
我只是想知道

220
00:11:25,470 --> 00:11:27,080
你为什么要在第二种表示方法中

221
00:11:27,180 --> 00:11:28,870
要使用函数间隔

222
00:11:28,980 --> 00:11:31,170
为什么要对它除以||w||?

223
00:11:31,270 --> 00:11:32,410
让我看看

224
00:11:32,520 --> 00:11:36,720
我不是很明白你的问题

225
00:11:36,820 --> 00:11:39,040
让我尝试再说明一下 这是我的目标

226
00:11:39,160 --> 00:11:42,460
让我看看

227
00:11:42,570 --> 00:11:44,550
这个优化问题的参数是

228
00:11:44,660 --> 00:11:45,960
γ ?  w和b

229
00:11:46,060 --> 00:11:48,940
我希望让一个已有的凸优化软件

230
00:11:48,940 --> 00:11:50,790
来帮我解决这个问题

231
00:11:50,870 --> 00:11:53,120
用来解出这些参数

232
00:11:53,230 --> 00:11:57,170
并且我加入了这个约束

233
00:11:57,250 --> 00:11:58,350
使得产生的任何值

234
00:11:58,450 --> 00:12:02,790
都要满足这个不等式

235
00:12:02,910 --> 00:12:06,630
这意味着每个样本的

236
00:12:06,750 --> 00:12:09,710
函数间隔都要大于等于

237
00:12:09,830 --> 00:12:11,100
γ ?

238
00:12:11,190 --> 00:12:12,620
这是一个对于函数间隔

239
00:12:12,730 --> 00:12:13,950
γ ?的约束

240
00:12:14,070 --> 00:12:16,030
但是我希望最大化的

241
00:12:16,140 --> 00:12:17,670
并不是函数间隔

242
00:12:17,800 --> 00:12:19,650
我真正希望最大化的  换句话说

243
00:12:19,760 --> 00:12:20,950
我的最优化目标

244
00:12:21,060 --> 00:12:24,520
是γ ?/(||w||)

245
00:12:24,630 --> 00:12:26,600
也就是几何间隔

246
00:12:26,710 --> 00:12:29,870
我的优化目标是

247
00:12:29,970 --> 00:12:32,520
我希望最大化函数间隔

248
00:12:32,630 --> 00:12:35,910
除以||w||的值  同时保证

249
00:12:36,070 --> 00:12:38,890
每个样本的函数间隔

250
00:12:38,990 --> 00:12:40,510
都至少是γ ?

251
00:12:40,610 --> 00:12:41,600
现在明白了吗?

252
00:12:41,710 --> 00:12:46,110
你说要

253
00:12:46,200 --> 00:12:49,340
最大化γ或γ ?

254
00:12:49,440 --> 00:12:53,970
它们都是和参数w

255
00:12:54,090 --> 00:12:56,540
相关的  这是否意味着γ ?

256
00:12:56,650 --> 00:12:59,060
不再是独立变量?

257
00:12:59,180 --> 00:13:03,400
这个问题--

258
00:13:03,480 --> 00:13:08,310
实际上  我写的

259
00:13:08,410 --> 00:13:11,030
这个最优化问题

260
00:13:11,150 --> 00:13:13,700
目的是为了求解几何间隔

261
00:13:13,790 --> 00:13:19,120
对于这个问题--

262
00:13:19,220 --> 00:13:21,280
你问题说的是γ ?是否为w和b的函数吗?

263
00:13:21,630 --> 00:13:22,910
实际上

264
00:13:23,030 --> 00:13:24,710
根据我之前的数学定义  确实如此

265
00:13:24,820 --> 00:13:27,100
但是我之所以

266
00:13:27,210 --> 00:13:28,970
这样提出这个最优化问题

267
00:13:29,050 --> 00:13:31,950
是因为我希望借助于一些已有的

268
00:13:32,020 --> 00:13:33,100
凸优化软件来进行求解

269
00:13:33,190 --> 00:13:35,560
如果你有软件

270
00:13:35,640 --> 00:13:37,310
用来处理凸优化问题

271
00:13:37,370 --> 00:13:39,920
那么我会将这些变量

272
00:13:39,980 --> 00:13:41,090
都视为独立变量

273
00:13:41,170 --> 00:13:43,420
并且让我的凸优化软件

274
00:13:43,520 --> 00:13:46,150
帮我找到γ  w和b的值

275
00:13:46,250 --> 00:13:48,450
并且在满足约束的条件下

276
00:13:48,550 --> 00:13:50,120
使要求的值越大越好

277
00:13:50,200 --> 00:13:53,330
实际上  当我们这样做的时候

278
00:13:53,420 --> 00:13:55,570
软件会为我们

279
00:13:55,670 --> 00:13:57,610
选择尽可能大的γ

280
00:13:57,720 --> 00:14:00,900
因为它是我们的优化目标:

281
00:14:00,990 --> 00:14:02,810
我们尝试最大化的值就是γ ?

282
00:14:02,920 --> 00:14:06,260
所以对于任何w和b

283
00:14:06,370 --> 00:14:08,210
我们的软件都会使γ ?尽可能的大

284
00:14:08,320 --> 00:14:10,590
γ ?最大可以有多大?

285
00:14:10,690 --> 00:14:13,020
这是由约束条件限制的

286
00:14:13,120 --> 00:14:14,510
约束条件说的是

287
00:14:14,620 --> 00:14:17,650
每个样本的函数间隔都必须

288
00:14:17,740 --> 00:14:21,280
大于等于γ ? 所以

289
00:14:21,380 --> 00:14:24,460
你能取得最大的γ ?的值

290
00:14:24,540 --> 00:14:27,020
将会是最小的函数间隔的值

291
00:14:27,140 --> 00:14:29,440
所以当你求解这个最优化问题时

292
00:14:29,560 --> 00:14:32,350
你得到的γ ?的值

293
00:14:32,450 --> 00:14:35,690
实际上就是你训练集合中样本的

294
00:14:35,770 --> 00:14:38,980
最小的函数间隔的值 Justin?

295
00:14:39,010 --> 00:14:40,340
好的  我只是想知道

296
00:14:40,450 --> 00:14:42,340
我对这些表述有些困惑

297
00:14:42,460 --> 00:14:44,660
你有两类数据  你会说

298
00:14:44,760 --> 00:14:46,620
"好的  请画一条线

299
00:14:46,730 --> 00:14:49,020
并且最大化

300
00:14:49,120 --> 00:14:51,090
这条线和这些点之间的

301
00:14:51,170 --> 00:14:52,820
最小距离 "

302
00:14:52,920 --> 00:14:54,950
看起来我们要做的就是这样的事

303
00:14:55,030 --> 00:14:55,840
但是--

304
00:14:55,930 --> 00:14:58,280
看起来我们描述的东西要远比我们想做的复杂

305
00:14:58,370 --> 00:15:00,730
我想知道其中的区别

306
00:15:00,820 --> 00:15:02,480
我知道了 我的意思是  


307
00:15:02,570 --> 00:15:04,790
你的问题--对于两类数据

308
00:15:04,860 --> 00:15:06,590
我们想找到一个分隔的超平面

309
00:15:06,670 --> 00:15:09,890
这确实比尝试

310
00:15:09,960 --> 00:15:10,920
找一条分隔线更复杂

311
00:15:11,010 --> 00:15:14,590
我重复一下问题

312
00:15:14,720 --> 00:15:16,740
因为我不确定你的声音是否会被录下来

313
00:15:16,840 --> 00:15:19,100
这个问题的答案是

314
00:15:19,170 --> 00:15:20,250
我们描述的就是这个问题

315
00:15:20,330 --> 00:15:21,860
这个问题说的就是:

316
00:15:21,950 --> 00:15:25,060
给定两类数据

317
00:15:25,140 --> 00:15:26,260
正样本和负样本

318
00:15:26,350 --> 00:15:29,220
我们讲的这些就是对这个问题的形式化描述

319
00:15:29,340 --> 00:15:32,970
我要找一条分隔线

320
00:15:33,050 --> 00:15:34,710
将两类样本分隔开来

321
00:15:34,830 --> 00:15:37,700
同时使点到线的最坏情况下

322
00:15:37,790 --> 00:15:39,940
的距离最大

323
00:15:40,020 --> 00:15:42,360
明白吗?什么?

324
00:15:42,470 --> 00:15:43,610
为什么你只关心

325
00:15:43,720 --> 00:15:44,520
最坏情况下的距离呢?

326
00:15:44,620 --> 00:15:46,420
现在

327
00:15:46,500 --> 00:15:47,580
为什么我们只关心最坏情形的距离?

328
00:15:47,680 --> 00:15:50,150
现在我们只关心

329
00:15:50,270 --> 00:15:52,260
最坏情形的举例

330
00:15:52,340 --> 00:15:54,110
我们稍后会回来修改这个条件

331
00:15:54,220 --> 00:15:57,140
对于现在来说  选取最坏情形的距离

332
00:15:57,230 --> 00:15:58,750
是因为它是一种很好的方式

333
00:15:58,860 --> 00:15:59,900
可以对最优化问题进行形式化的描述

334
00:16:00,010 --> 00:16:01,950
我们稍后会回来改进这个条件

335
00:16:02,050 --> 00:16:04,920
好的  明白的话请举手--

336
00:16:05,010 --> 00:16:08,600
这样的形式化方法大家明白了吗?很好

337
00:16:08,690 --> 00:16:13,600
好的  让我看看--

338
00:16:13,710 --> 00:16:15,070
这只是一个同样问题的

339
00:16:15,180 --> 00:16:17,070
不同的表述形式

340
00:16:17,180 --> 00:16:19,990
一方面  我想避免使用这样糟糕的

341
00:16:20,070 --> 00:16:22,860
非凸性约束  另一方面

342
00:16:22,950 --> 00:16:26,810
我又加入了一个糟糕的非凸性的优化目标

343
00:16:26,920 --> 00:16:29,100
这并不是一个以w为参数的

344
00:16:29,210 --> 00:16:32,300
凸性函数

345
00:16:32,390 --> 00:16:35,010
所以你不能保证

346
00:16:35,140 --> 00:16:37,830
像梯度下降这样的算法一定能找到全局最小值

347
00:16:37,940 --> 00:16:42,210
至少不能立即找到

348
00:16:42,300 --> 00:16:43,680
因为这个问题是非凸性的

349
00:16:43,780 --> 00:16:55,250
所以我们可以做的是

350
00:16:55,350 --> 00:16:58,880
记得之前我们提到过可以添加

351
00:16:58,960 --> 00:17:01,440
任何奇怪的参数的缩放条件

352
00:17:01,530 --> 00:17:04,370
所以你可以选择添加任意像这样的缩放条件

353
00:17:04,460 --> 00:17:05,520
都不会影响结果

354
00:17:05,630 --> 00:17:09,520
我们要添加的缩放条件是这样的

355
00:17:09,620 --> 00:17:16,090
再强调一次  对于今天的内容

356
00:17:16,230 --> 00:17:17,970
我会假设

357
00:17:18,060 --> 00:17:19,370
这些样本都是线性可分隔的

358
00:17:19,460 --> 00:17:20,810
也就是说你可以通过一个线性平面

359
00:17:20,910 --> 00:17:22,130
将正负样本分隔开

360
00:17:22,250 --> 00:17:24,540
我们稍后会回来修正这一条件

361
00:17:24,650 --> 00:17:26,860
这是我要对w

362
00:17:26,950 --> 00:17:28,390
添加的缩放约束

363
00:17:28,490 --> 00:17:30,540
我希望添加一个约束

364
00:17:30,650 --> 00:17:35,530
使得函数间隔等于1

365
00:17:35,640 --> 00:17:40,500
另外一种写法是

366
00:17:40,610 --> 00:17:45,100
我希望使这个式子的最小值

367
00:17:45,210 --> 00:17:54,260
等于1

368
00:17:54,360 --> 00:17:57,020
很明显  这是一个缩放约束

369
00:17:57,120 --> 00:18:00,020
因为假设你已经解出了w和b

370
00:18:00,140 --> 00:18:04,160
并且发现最差情形的函数间隔

371
00:18:04,270 --> 00:18:06,020
是10或者其它的值

372
00:18:06,120 --> 00:18:09,500
这样  通过对w和b除以10或其它数值

373
00:18:09,590 --> 00:18:11,730
我可以将函数间隔变为1

374
00:18:11,820 --> 00:18:15,900
所以这是一个隐含的缩放条件

375
00:18:16,000 --> 00:18:19,890
这样的写法更为简洁

376
00:18:19,980 --> 00:18:21,690
这个缩放约束规定

377
00:18:21,790 --> 00:18:23,310
函数间隔一定等于1

378
00:18:23,420 --> 00:18:29,500
所以现在我们可以将这个

379
00:18:29,610 --> 00:18:32,090
缩放约束加入我们之前所写的第二个

380
00:18:32,190 --> 00:18:33,480
最优化问题的表述中

381
00:18:33,570 --> 00:18:37,100
从而得到下面的最优化问题:

382
00:18:37,210 --> 00:18:40,170
使||w||的平方最小化

383
00:18:40,240 --> 00:18:59,700
之前我们希望使

384
00:18:59,730 --> 00:19:03,220
γ ?/|(|w| )|  最大化

385
00:19:03,330 --> 00:19:06,650
所以在新的条件下  这等同于使1/||w||最大化

386
00:19:06,740 --> 00:19:08,370
所以这等价于

387
00:19:08,490 --> 00:19:11,140
使|(|w| )|^2最小化 这个目标函数很好

388
00:19:11,230 --> 00:19:13,860
使1/||w||最大化就是使|(|w| )|^2最小化

389
00:19:13,950 --> 00:19:15,560
这些是我们的约束

390
00:19:15,640 --> 00:19:17,330
我已经加入了约束

391
00:19:17,420 --> 00:19:18,900
函数间隔等于1

392
00:19:19,020 --> 00:19:26,930
这是我对于

393
00:19:27,020 --> 00:19:31,290
这个最优间隔分类器问题

394
00:19:31,370 --> 00:19:33,370
的最终的形式化形式

395
00:19:33,440 --> 00:19:34,710
至少现在是这样的

396
00:19:34,810 --> 00:19:41,830
可以画一张图帮你们加深理解

397
00:19:41,940 --> 00:19:44,970
我们的最优化目标的意思是

398
00:19:45,060 --> 00:19:46,750
希望最小化w的模

399
00:19:46,860 --> 00:19:50,650
所以我们的最优化目标

400
00:19:50,740 --> 00:19:52,000
就是一个二次函数

401
00:19:52,130 --> 00:19:54,460
这张图可以展示出来

402
00:19:54,570 --> 00:19:58,410
这里是w_1  这里是w_2

403
00:19:58,500 --> 00:19:59,770
你可能希望最小化这样的

404
00:19:59,860 --> 00:20:01,090
二次函数--

405
00:20:01,190 --> 00:20:02,940
二次函数看起来

406
00:20:03,030 --> 00:20:04,380
是像这样的

407
00:20:04,480 --> 00:20:07,890
此外  你还有几个

408
00:20:07,970 --> 00:20:09,400
对参数的线性约束

409
00:20:09,510 --> 00:20:11,780
所以你可能有这样的一个线性约束

410
00:20:11,890 --> 00:20:14,060
去掉了这半个平面  或者这样的线性约束

411
00:20:14,150 --> 00:20:15,340
去掉了这半个平面

412
00:20:15,450 --> 00:20:21,170
这里再去掉半个平面

413
00:20:21,270 --> 00:20:24,940
这张图展示的是  你有一个二次函数

414
00:20:25,010 --> 00:20:30,740
与此同时你排除掉了若干个半平面

415
00:20:30,820 --> 00:20:33,320
每个半平面对应着一个线性约束

416
00:20:33,430 --> 00:20:35,270
我很希望用3D形式展示出来

417
00:20:35,380 --> 00:20:36,460
我在想是否能够画成3D的

418
00:20:36,570 --> 00:20:38,820
希望你们能看到

419
00:20:38,930 --> 00:20:41,480
这样的凸性问题中是没有局部最优值的

420
00:20:41,590 --> 00:20:45,000
这时你可以在这些还没有被排除的点上

421
00:20:45,130 --> 00:20:48,530
执行梯度下降算法

422
00:20:48,650 --> 00:20:50,600
从而收敛到一个局部最优值

423
00:20:50,700 --> 00:20:55,670
这是一个凸优化问题

424
00:20:55,770 --> 00:20:58,470
它具有一些非常漂亮的性质

425
00:20:58,630 --> 00:21:03,390
有问题吗?

426
00:21:03,460 --> 00:21:18,550
如果明白的话请举手

427
00:21:18,650 --> 00:21:26,610
好的 这就是

428
00:21:26,710 --> 00:21:28,860
最优间隔分类器算法

429
00:21:28,940 --> 00:21:31,040
实际上

430
00:21:31,110 --> 00:21:33,280
这是一个凸优化问题

431
00:21:33,380 --> 00:21:36,130
所以你可以将这个形式化后的问题

432
00:21:36,210 --> 00:21:39,590
直接交给一个无需定制的软件去求解--

433
00:21:39,690 --> 00:21:42,250
这样的软件被称为QP或者二次程序软件

434
00:21:42,330 --> 00:21:43,750
这类优化问题

435
00:21:43,860 --> 00:21:44,890
是二次函数的优化

436
00:21:45,010 --> 00:21:47,050
目标函数是一个二次函数

437
00:21:47,130 --> 00:21:48,610
除此之外还有一些线性约束--

438
00:21:48,710 --> 00:21:50,280
所以你可以下载一些软件

439
00:21:50,370 --> 00:21:52,020
用它们来求解最优化问题

440
00:21:52,130 --> 00:21:54,990
当然你也许可以用

441
00:21:55,100 --> 00:21:56,910
梯度下降算法实现

442
00:21:57,020 --> 00:21:58,670
因为你有这样的约束

443
00:21:58,770 --> 00:21:59,990
尽管这样的话你需要

444
00:22:00,100 --> 00:22:01,470
修改算法以适应工作的需求

445
00:22:01,580 --> 00:22:05,340
到这里我们可以说

446
00:22:05,430 --> 00:22:07,180
我们对于这个问题的形式化是成功的

447
00:22:07,290 --> 00:22:09,370
但是现在我们

448
00:22:09,490 --> 00:22:12,300
要偏离主题讲一讲

449
00:22:12,410 --> 00:22:13,820
原始问题和对偶优化问题

450
00:22:13,930 --> 00:22:16,530
实际上

451
00:22:16,620 --> 00:22:18,840
稍后我会回来

452
00:22:18,930 --> 00:22:21,250
从这些导出另一种

453
00:22:21,340 --> 00:22:22,910
非常不同的最优化问题

454
00:22:23,020 --> 00:22:26,130
我们这样做的原因是

455
00:22:26,210 --> 00:22:27,840
这类最优化问题

456
00:22:27,940 --> 00:22:30,140
具有一些性质

457
00:22:30,240 --> 00:22:32,250
可以将它修改成一个非常高效的算法

458
00:22:32,360 --> 00:22:35,560
除此之外  我还会引出

459
00:22:35,680 --> 00:22:38,130
对偶形式化  从而允许我们

460
00:22:38,220 --> 00:22:41,370
将最优间隔分类器应用在

461
00:22:41,480 --> 00:22:44,720
维数很高的特征向量空间中--

462
00:22:44,810 --> 00:22:48,440
甚至可以在无限维的特征向量空间中

463
00:22:48,550 --> 00:22:53,690
我们一会儿再回来 我想知道

464
00:22:53,810 --> 00:22:57,850
因为我在将凸优化问题

465
00:22:57,950 --> 00:23:03,870
所以你们中

466
00:23:03,970 --> 00:23:07,340
有多少人还记得微积分

467
00:23:07,410 --> 00:23:10,990
中的拉格朗日乘数法?

468
00:23:11,090 --> 00:23:14,480
它可以用来求解像这样的最优化问题--

469
00:23:14,580 --> 00:23:16,310
例如:最小化 最大化问题

470
00:23:16,420 --> 00:23:17,980
在满足一定数量的约束条件的前提下

471
00:23:18,090 --> 00:23:19,710
你们中有多少人

472
00:23:19,800 --> 00:23:21,200
记得拉格朗日乘数法?

473
00:23:21,300 --> 00:23:23,870
很好  有些人记得

474
00:23:23,980 --> 00:23:26,090
如果你不记得了  不要担心

475
00:23:26,170 --> 00:23:28,720
我这里会简要地介绍一下

476
00:23:28,830 --> 00:23:30,760
但是我真正想讲的是

477
00:23:30,860 --> 00:23:32,310
它的一种一般化的形式

478
00:23:32,410 --> 00:23:34,040
你可能在微积分课中见过

479
00:23:34,150 --> 00:23:36,980
也可能没见过

480
00:23:37,090 --> 00:23:38,480
如果你之前没见过

481
00:23:38,580 --> 00:23:39,670
也不要担心

482
00:23:39,770 --> 00:23:45,630
拉格朗日乘数法是这样的

483
00:23:45,730 --> 00:23:50,080
假设有一个函数

484
00:23:50,160 --> 00:23:52,020
例如f(w)  你想使它最大化或最小化

485
00:23:52,130 --> 00:23:57,070
与此同时要满足一些约束

486
00:23:57,190 --> 00:24:01,730
对于每个i  必须保证约束函数的值为0

487
00:24:01,820 --> 00:24:03,980
给定这些约束

488
00:24:04,090 --> 00:24:07,370
我可以将它写成向量的形式

489
00:24:07,480 --> 00:24:12,910
将整个向量表示成h(w)

490
00:24:13,870 --> 00:24:20,680
它等于0向量 这里的0上面有个箭头

491
00:24:20,800 --> 00:24:22,860
表示所有元素都是0的向量

492
00:24:22,970 --> 00:24:29,050
你想求解这个最优化问题

493
00:24:29,070 --> 00:24:30,290
你们中的一些人应该见过

494
00:24:30,380 --> 00:24:31,660
拉格朗日乘数法

495
00:24:31,770 --> 00:24:35,840
首先应该创建一个拉格朗日算子

496
00:24:35,920 --> 00:24:47,640
它应该等于原始的目标函数

497
00:24:47,740 --> 00:24:50,240
加上这些限制函数的

498
00:24:50,340 --> 00:24:51,520
线性组合

499
00:24:51,630 --> 00:24:55,390
这些参数

500
00:24:55,490 --> 00:24:57,600
被称之为拉格朗日乘数

501
00:24:57,700 --> 00:25:03,640
之后解决这个

502
00:25:03,730 --> 00:25:07,060
最优化问题的方法是

503
00:25:07,140 --> 00:25:09,170
对每个原始求偏导数

504
00:25:09,240 --> 00:25:12,090
之后将其设为0

505
00:25:12,190 --> 00:25:15,900
之后对

506
00:25:15,960 --> 00:25:17,840
拉格朗日乘数求偏导数

507
00:25:17,950 --> 00:25:18,930
并经其设为0

508
00:25:19,040 --> 00:25:21,930
理论上可以证明

509
00:25:22,030 --> 00:25:25,640
w^*是一个

510
00:25:25,740 --> 00:25:34,020
最优解

511
00:25:34,090 --> 00:25:49,540
是这个条件的必要条件:存在β^*  


512
00:25:49,640 --> 00:25:50,560
没错

513
00:25:50,680 --> 00:25:51,860
这个反写的"E"表示存在

514
00:25:51,960 --> 00:25:53,260
存在

515
00:25:53,350 --> 00:25:55,740
β^*  使得

516
00:25:55,850 --> 00:26:20,870
这些偏导数的值为0

517
00:26:20,960 --> 00:26:26,700
所以根据这个结论  用拉格朗日乘数法

518
00:26:26,810 --> 00:26:29,530
求解的过程是  创建一个拉格朗日算子

519
00:26:29,620 --> 00:26:31,770
之后相对于

520
00:26:31,880 --> 00:26:35,420
原始参数w

521
00:26:35,520 --> 00:26:38,820
和拉格朗日乘数β求偏导数

522
00:26:38,970 --> 00:26:41,410
并令偏导数等于0

523
00:26:41,510 --> 00:26:43,320
之后对方程组求解

524
00:26:43,430 --> 00:26:45,080
之后检查一下得到的解

525
00:26:45,190 --> 00:26:56,370
是否确实为一个最小值 好的

526
00:26:56,470 --> 00:26:57,770
接下来我要写的

527
00:26:57,860 --> 00:27:01,830
是拉格朗日乘数法的一种一般化形式

528
00:27:01,920 --> 00:27:03,780
如果你之前没有见过

529
00:27:03,860 --> 00:27:06,060
也不要担心

530
00:27:06,160 --> 00:27:07,980
我接下来要写的

531
00:27:08,090 --> 00:27:09,280
是一种拉格朗日乘数法的扩展形式

532
00:27:09,360 --> 00:27:12,440
用来求解一类更为困难的

533
00:27:12,550 --> 00:27:14,130
带约束的优化问题

534
00:27:14,220 --> 00:27:19,040
假设你希望最小化f(w)

535
00:27:19,130 --> 00:27:24,830
同时满足一些约束条件

536
00:27:24,920 --> 00:27:34,580
让一些g_i (w)≤0  同时让一些h_i (w)=0

537
00:27:34,660 --> 00:27:40,810
这里再一次使用了向量的表示方法

538
00:27:40,880 --> 00:27:43,820
这里g(w)是0向量

539
00:27:43,880 --> 00:27:47,580
h(w)也是0向量

540
00:27:47,660 --> 00:27:50,000
在这种一般化的情况下

541
00:27:50,080 --> 00:27:51,760
我们既有不等式约束

542
00:27:51,850 --> 00:27:53,370
也有等式约束

543
00:27:53,480 --> 00:28:04,980
接下来是拉格朗日算子  在这种情况下

544
00:28:05,480 --> 00:28:07,070
它被称为一般化的拉格朗日算子

545
00:28:07,160 --> 00:28:10,090
其中既包括原始的

546
00:28:10,170 --> 00:28:12,610
函数和参数w

547
00:28:12,730 --> 00:28:15,470
也包括两组拉格朗日乘数

548
00:28:15,560 --> 00:28:20,980
α和β 这里是f(w)

549
00:28:21,070 --> 00:28:39,910
这一部分很酷

550
00:28:40,010 --> 00:28:46,090
我们接下来要定义?_P (w)

551
00:28:46,180 --> 00:28:52,060
它应该等于:

552
00:28:52,120 --> 00:28:53,900
max_█(α  β @α_i≥0) L(w  α  β)

553
00:28:54,000 --> 00:29:00,200
max_█(α  β @α_i≥0) L(w  α  β)

554
00:29:00,280 --> 00:29:16,600
我希望你们考虑

555
00:29:16,710 --> 00:29:22,650
这样的优化问题

556
00:29:22,830 --> 00:29:26,440
P^*等于

557
00:29:26,530 --> 00:29:28,940
α大于拉格朗日0

558
00:29:29,030 --> 00:29:40,970
它就等于:min┬w?〖?_P (w)〗

559
00:29:41,080 --> 00:29:46,830
我们可以起个名字

560
00:29:46,920 --> 00:29:48,910
这个下标P表示原始问题

561
00:29:49,030 --> 00:29:52,230
原始问题表示的是这一部分描述的问题

562
00:29:52,310 --> 00:29:59,150
这里描述的最优化问题被称为

563
00:29:59,230 --> 00:30:00,720
原始问题

564
00:30:00,820 --> 00:30:02,870
这意味着这类问题

565
00:30:02,980 --> 00:30:04,050
是需要被解决的最原始的问题

566
00:30:04,160 --> 00:30:07,230
稍后  我们会推导出它的另外一个版本

567
00:30:07,330 --> 00:30:09,590
"p"代表"primal"

568
00:30:09,690 --> 00:30:10,740
这类问题被称为原始问题

569
00:30:10,840 --> 00:30:14,360
现在  我想让你们再次考虑	

570
00:30:14,480 --> 00:30:16,200
?_p (w)

571
00:30:16,290 --> 00:30:18,590
特别地  我希望考虑

572
00:30:18,700 --> 00:30:20,370
当我们使?_p (w)

573
00:30:20,470 --> 00:30:25,970
最小化时  到底发生了什么

574
00:30:26,080 --> 00:30:36,510
让我们看看?_p (w)到底表示了什么

575
00:30:36,600 --> 00:30:44,710
注意到如果g_i (w)>0

576
00:30:44,820 --> 00:30:46,510
让我们取w的值

577
00:30:46,590 --> 00:30:49,230
那么?_p (w)的值是什么?

578
00:30:49,320 --> 00:30:53,650
如果w违反了原始问题的约束

579
00:30:53,740 --> 00:31:04,460
那么?_p (w)的值将会无穷大 为什么呢?

580
00:31:04,550 --> 00:31:07,450
请切回上一块黑板

581
00:31:07,550 --> 00:31:10,840
假设我选取的w

582
00:31:10,940 --> 00:31:12,240
违反了其中的一条约束

583
00:31:12,330 --> 00:31:18,870
如果g_i (w)>0  那么

584
00:31:18,970 --> 00:31:20,710
?_p (w) 应该是这个拉格朗日

585
00:31:20,710 --> 00:31:21,730
算子能够取得的最大值

586
00:31:21,830 --> 00:31:25,930
如果其中的一个g_i (w)是正的

587
00:31:26,010 --> 00:31:29,710
那么我只需要让它对应的α_i取任意大的值

588
00:31:29,830 --> 00:31:31,340
我就可以让整个算子的值无穷大

589
00:31:31,450 --> 00:31:34,150
所以如果w违反了

590
00:31:34,240 --> 00:31:36,760
原始问题中关于g_i的约束

591
00:31:36,870 --> 00:31:39,980
那么只需要任意增大相应的α

592
00:31:40,070 --> 00:31:42,360
就可以使拉格朗日算子的值取到正无穷

593
00:31:42,450 --> 00:31:45,590
同理

594
00:31:45,690 --> 00:31:47,160
按照类似的想法

595
00:31:47,280 --> 00:31:52,870
如果h_i (w)不为0

596
00:31:53,120 --> 00:31:58,660
那么?_p (w)

597
00:31:58,750 --> 00:32:01,430
也会为正无穷

598
00:32:01,520 --> 00:32:04,360
因为如果h_i (w)不为0

599
00:32:04,520 --> 00:32:07,160
那么找到拉格朗日算子中

600
00:32:07,270 --> 00:32:10,010
对应的β_i h_i项

601
00:32:10,120 --> 00:32:12,960
通过将β_i设定成正无穷

602
00:32:13,060 --> 00:32:15,240
或负无穷(这取决于h_i的符号)

603
00:32:15,330 --> 00:32:17,640
我也可以让这一项无限大

604
00:32:17,740 --> 00:32:37,120
否则  ?_p (w)就等于f(w)

605
00:32:37,210 --> 00:32:41,110
实际上  如果w的值

606
00:32:41,200 --> 00:32:44,280
满足所有的约束

607
00:32:44,360 --> 00:32:47,400
那么我们使算子的值最大化的方式

608
00:32:47,470 --> 00:32:51,940
是使所有的拉格朗日乘数项

609
00:32:52,030 --> 00:32:55,000
求和的值

610
00:32:55,080 --> 00:32:56,740
变为0

611
00:32:56,840 --> 00:33:00,720
这样?_p (w)仅剩f(w)项

612
00:33:00,820 --> 00:33:12,470
这样  ?_p (w)等于f(w)

613
00:33:12,560 --> 00:33:18,350
如果所有关于

614
00:33:18,440 --> 00:33:23,600
g_i 和h_i的约束全部满足

615
00:33:23,690 --> 00:33:27,150
否则的话等于正无穷

616
00:33:27,270 --> 00:33:35,400
所以我这里写的问题

617
00:33:35,490 --> 00:33:37,600
也就是对所有的w  使?_p (w)最小  


618
00:33:37,690 --> 00:33:40,310
这个问题就是原始问题

619
00:33:40,400 --> 00:33:48,160
它和我开始时提出的原始问题

620
00:33:48,250 --> 00:33:49,970
实际上是同样的问题

621
00:33:50,080 --> 00:33:52,360
因为如果你选择了一个

622
00:33:52,460 --> 00:33:54,330
违反了约束条件的w  你会得到正无穷

623
00:33:54,420 --> 00:33:57,280
如果你满足约束  你将得到f(w)

624
00:33:57,650 --> 00:33:59,890
这和这样的说法


625
00:33:59,970 --> 00:34:00,930
是等价的

626
00:34:01,020 --> 00:34:03,220
"满足约束的同时  最小化f(w) "

627
00:34:03,330 --> 00:34:06,480
这就是最小化?_p (w)的真实含义

628
00:34:06,560 --> 00:34:12,910
如果明白的话请举手 很好

629
00:34:13,000 --> 00:34:26,430
好的  希望你们没有发疯

630
00:34:26,480 --> 00:34:27,940
因为到现在为止我讲了这么多东西

631
00:34:28,010 --> 00:34:28,840
当我们回头来看的时候

632
00:34:28,920 --> 00:34:30,190
会发现我们讲的这些东西都是有必要的

633
00:34:30,270 --> 00:34:31,890
这一部分很有趣

634
00:34:31,970 --> 00:34:35,050
下面让我们开始将对偶问题

635
00:34:35,140 --> 00:34:46,100
我们需要求出?_D  这里的D表示对偶

636
00:34:46,180 --> 00:34:49,300
这是一个以α  β

637
00:34:49,380 --> 00:34:51,070
这些拉格朗日乘数为变量的函数

638
00:34:51,170 --> 00:34:53,360
它并不以w为变量 为了求出它

639
00:34:53,440 --> 00:34:57,120
我希望最小化之前定义的

640
00:34:57,120 --> 00:35:00,460
一般化的拉格朗日算子

641
00:35:00,540 --> 00:35:17,640
我的对偶问题是这样的

642
00:35:17,730 --> 00:35:26,980
换句话说  就是对它取最大值

643
00:35:27,040 --> 00:35:31,370
这是我的对偶最优化问题

644
00:35:31,470 --> 00:35:33,360
在α和β上取值

645
00:35:33,440 --> 00:35:35,430
使?_D (α  β)最大化

646
00:35:35,520 --> 00:35:38,280
我想这个优化问题

647
00:35:38,360 --> 00:35:39,430
就是我的对偶问题

648
00:35:39,520 --> 00:35:42,430
我希望你们将这个式子

649
00:35:42,490 --> 00:35:44,890
和我们的原始最优化问题进行对比

650
00:35:44,960 --> 00:35:49,500
唯一的区别是这里的顺序是max  min

651
00:35:49,570 --> 00:35:51,590
这里我调换了原有的max和min的顺序

652
00:35:51,670 --> 00:35:53,150
这是原始问题

653
00:35:53,230 --> 00:35:54,770
和对偶问题的区别

654
00:35:54,860 --> 00:36:02,810
实际上  这是一个事实

655
00:36:02,910 --> 00:36:06,830
即:通常情况下

656
00:36:06,930 --> 00:36:08,980
d^*≤p^* 换句话说

657
00:36:09,050 --> 00:36:10,960
我记得我之前定义过p^

658
00:36:11,020 --> 00:36:13,180
p^*是原始最优化问题的值

659
00:36:13,270 --> 00:36:18,990
换句话说  通常情况下

660
00:36:19,100 --> 00:36:23,330
对某个函数取max min的值

661
00:36:23,390 --> 00:36:27,550
总是小于等于对其取min max的值

662
00:36:27,620 --> 00:36:29,590
这是一个普遍的事实

663
00:36:29,680 --> 00:36:31,700
举个具体的例子

664
00:36:31,780 --> 00:36:38,790
对y属于--哦  对不起

665
00:36:38,870 --> 00:36:46,180
这一项的值

666
00:36:46,270 --> 00:36:51,060
要小于等于这一项的值

667
00:36:51,160 --> 00:37:12,750
这个不等式

668
00:37:12,920 --> 00:37:15,560
对于任何函数都是成立的

669
00:37:15,650 --> 00:37:18,210
这仅仅是一个特殊的例子

670
00:37:18,300 --> 00:37:21,010
对不起

671
00:37:21,110 --> 00:37:23,210
对 I取最小值

672
00:37:23,300 --> 00:37:28,130
总是等于0  因为无论y取何值

673
00:37:28,180 --> 00:37:30,080
你都可以令x取不同的值

674
00:37:30,150 --> 00:37:31,590
所以结果总是0

675
00:37:31,680 --> 00:37:36,550
而如果我改变了min 和max的值

676
00:37:36,650 --> 00:37:39,050
那么里面一层的结果总会是1

677
00:37:39,160 --> 00:37:41,220
所以0总是小于等于1

678
00:37:41,300 --> 00:37:43,890
更为一般地  这个

679
00:37:43,950 --> 00:37:46,100
max min项

680
00:37:46,160 --> 00:37:47,690
总是小于min max项

681
00:37:47,780 --> 00:37:49,440
对于这里的任何函数都成立

682
00:37:49,550 --> 00:37:53,410
但是事实证明

683
00:37:53,470 --> 00:37:54,860
在某些特定条件下

684
00:37:54,950 --> 00:38:05,430
这两个最优化问题会取相同的值

685
00:38:05,540 --> 00:38:08,170
在一些特定条件下

686
00:38:08,280 --> 00:38:11,260
原始问题和对偶问题会取相同的值

687
00:38:11,400 --> 00:38:16,550
这是你可以用对偶问题的求解

688
00:38:16,660 --> 00:38:18,350
代替原始问题的求解

689
00:38:18,500 --> 00:38:22,340
这样做的原因是

690
00:38:22,440 --> 00:38:25,020
稍后我们会再最优间隔分类器问题

691
00:38:25,110 --> 00:38:26,070
以及支持向量机问题中看到

692
00:38:26,460 --> 00:38:28,150
对偶问题经常会更为简单

693
00:38:28,230 --> 00:38:29,490
而且和原始问题相比

694
00:38:29,590 --> 00:38:34,860
具有更多有用的性质

695
00:38:34,890 --> 00:38:48,550
为了--

696
00:38:48,620 --> 00:39:02,500
我现在要做的是

697
00:39:02,570 --> 00:39:04,920
正式地写出这些

698
00:39:05,020 --> 00:39:06,110
使原始问题和对偶问题

699
00:39:06,180 --> 00:39:07,630
等价的条件

700
00:39:07,720 --> 00:39:11,630
所以我们导出

701
00:39:11,710 --> 00:39:12,920
支持向量机算法

702
00:39:13,010 --> 00:39:14,710
的策略是

703
00:39:14,770 --> 00:39:17,020
我们会写出原始最优化问题

704
00:39:17,120 --> 00:39:19,700
我们之前已经做过了

705
00:39:19,780 --> 00:39:21,310
之后我们会推导出

706
00:39:21,390 --> 00:39:23,500
原始问题的对偶问题

707
00:39:23,560 --> 00:39:26,080
之后我们会求解对偶问题

708
00:39:26,150 --> 00:39:27,920
之后会进行一些修改

709
00:39:27,980 --> 00:39:29,770
这就是我们推导出支持向量机的方法

710
00:39:29,850 --> 00:39:32,740
现在

711
00:39:32,820 --> 00:39:34,290
出于完整性的原因

712
00:39:34,410 --> 00:39:36,200
我仅仅将这些条件写在这里

713
00:39:36,280 --> 00:39:37,940
也就是使原始问题和对偶问题

714
00:39:38,030 --> 00:39:43,660
获得相同解的条件 令f为凸函数

715
00:39:43,760 --> 00:39:47,990
如果你不明白什么叫凸函数

716
00:39:48,090 --> 00:39:50,780
对于这节课来说

717
00:39:50,860 --> 00:39:53,180
你可以认为这意味着

718
00:39:53,290 --> 00:39:55,400
它的Hessian矩阵是一个半正定矩阵

719
00:39:55,510 --> 00:39:57,480
例如  这样一个碗状的函数就是一个凸函数

720
00:39:57,580 --> 00:40:00,480
如果你想了解更多关于凸优化的知识

721
00:40:00,560 --> 00:40:04,210
欢迎来上这周由助教主持的

722
00:40:04,310 --> 00:40:13,010
讨论课 之后我们假设

723
00:40:13,100 --> 00:40:14,780
h_i约束是仿射函数

724
00:40:14,910 --> 00:40:18,820
这意味着

725
00:40:18,900 --> 00:40:21,630
h_i (w)=α_i^T w+b_i

726
00:40:21,740 --> 00:40:26,010
它实际上和线性函数有点类似

727
00:40:26,150 --> 00:40:28,110
如果没有b这项

728
00:40:28,240 --> 00:40:30,220
我们就说h_i是线性函数

729
00:40:30,280 --> 00:40:31,860
当我们这里有截距时

730
00:40:31,950 --> 00:40:33,410
我们用一个专门的术语:仿射函数

731
00:40:33,410 --> 00:40:34,700
来称呼它  而不再叫它线性函数

732
00:40:34,800 --> 00:40:46,740
之后让我们假设g_i是严格可执行的

733
00:40:46,840 --> 00:40:56,010
这意味着

734
00:40:56,120 --> 00:41:02,330
存在一个w  使得对于所有i

735
00:41:02,420 --> 00:41:05,900
g_i (w)小于0

736
00:41:05,970 --> 00:41:08,110
不要太在意

737
00:41:08,230 --> 00:41:09,210
我将这些写出来

738
00:41:09,310 --> 00:41:10,740
仅仅是为了保证完整性

739
00:41:10,840 --> 00:41:11,740
你们可以不用太在意

740
00:41:11,830 --> 00:41:13,300
技术细节 严格可执行的意思是

741
00:41:13,370 --> 00:41:15,920
存在一个w

742
00:41:16,030 --> 00:41:18,090
满足所有约束条件的同时  保证

743
00:41:18,180 --> 00:41:19,290
满足比原有的小于等于

744
00:41:19,290 --> 00:41:20,400
约束更严格的小于约束

745
00:41:20,510 --> 00:41:27,770
在这些条件下  存在w^

746
00:41:27,900 --> 00:41:34,010
α^*  β^

747
00:41:34,110 --> 00:41:36,080
w^*是原始问题的解

748
00:41:36,140 --> 00:41:42,380
α^*和β^

749
00:41:42,480 --> 00:41:44,590
是拉格朗日乘数  是对偶问题的解

750
00:41:44,700 --> 00:41:55,530
原始问题的值

751
00:41:55,590 --> 00:41:57,340
等于对偶问题的值

752
00:41:57,420 --> 00:41:59,760
等于

753
00:41:59,860 --> 00:42:03,990
拉格朗日乘数--对不起

754
00:42:04,060 --> 00:42:06,220
等于广义拉格朗日算子的值

755
00:42:06,310 --> 00:42:08,190
以w^*  α^* 和β^*为变量参数

756
00:42:08,260 --> 00:42:11,550
换句话说  你既可以求解原始问题

757
00:42:11,630 --> 00:42:13,880
也可以求解对偶问题 你都会得到相同的解

758
00:42:13,970 --> 00:42:20,790
此外  你的参数

759
00:42:20,880 --> 00:42:28,070
还要满足这些条件

760
00:42:28,190 --> 00:42:30,850
参数的偏导数将会是0

761
00:42:30,930 --> 00:42:34,640
记住这个等式

762
00:42:34,730 --> 00:42:36,860
我们稍后会用到它

763
00:42:36,920 --> 00:42:38,540
当我们用拉格朗日算子

764
00:42:38,620 --> 00:42:40,340
求解SVM问题的时候

765
00:42:40,460 --> 00:42:42,980
那时我们会对w求导

766
00:42:43,080 --> 00:42:45,690
用来推导出我们的对偶问题

767
00:42:45,790 --> 00:42:48,150
我们一会儿会自己进行这个步骤的运算

768
00:42:48,260 --> 00:42:53,290
对拉格朗日乘数β求

769
00:42:53,380 --> 00:42:55,780
偏导数的值是0

770
00:42:55,900 --> 00:43:09,860
事实证明这个式子也会成立

771
00:43:09,950 --> 00:43:14,960
这些条件

772
00:43:15,060 --> 00:43:31,300
被称为KKT互补条件

773
00:43:31,350 --> 00:43:34,330
KKT表示Karush-Kuhn-Tucker

774
00:43:34,410 --> 00:43:35,950
代表了这个定理的三个作者

775
00:43:36,040 --> 00:43:40,020
KKT有5个条件

776
00:43:40,110 --> 00:43:43,370
另外两个是--

777
00:43:43,490 --> 00:43:52,650
α_i≥0

778
00:43:52,730 --> 00:43:54,860
我们之前就有了这个条件

779
00:43:54,960 --> 00:43:57,580
而约束保证了这个条件的成立

780
00:43:57,680 --> 00:44:27,750
让我看看  好的

781
00:44:27,820 --> 00:44:32,090
让我们将刚刚讲过的内容

782
00:44:32,160 --> 00:44:38,420
应用到我们之前讲过的

783
00:44:38,490 --> 00:44:39,980
最优间隔优化问题

784
00:44:40,070 --> 00:44:44,250
我还要补充一点--

785
00:44:44,330 --> 00:44:48,170
关于这个KKT互补性条件

786
00:44:48,280 --> 00:44:52,660
我还要补充一点

787
00:44:52,740 --> 00:44:54,250
这个条件--

788
00:44:54,310 --> 00:44:56,810
在你得到的解中  你必须保证

789
00:44:56,900 --> 00:45:03,200
α_i^**g_i (w)=0  所以让我看看

790
00:45:03,290 --> 00:45:06,810
两个数的乘积等于0

791
00:45:06,900 --> 00:45:10,530
这意味着至少其中之一

792
00:45:10,620 --> 00:45:11,990
一定等于0

793
00:45:12,100 --> 00:45:14,710
由于这两项的乘积为0

794
00:45:14,790 --> 00:45:20,420
那么α_i和g_i之一一定为0

795
00:45:20,510 --> 00:45:23,110
这蕴含着--

796
00:45:23,160 --> 00:45:41,570
Karush-Kuhn-Tucker  多数人会简写成KKT

797
00:45:41,680 --> 00:45:43,000
但是我想向你们展示一下

798
00:45:43,050 --> 00:45:46,250
正确的拼写

799
00:45:46,340 --> 00:45:50,340
所以KKT互补性条件蕴含着

800
00:45:50,440 --> 00:45:53,510
如果α_i不为0

801
00:45:53,600 --> 00:46:01,810
那么它必然蕴含着:g_i (w^* )=0

802
00:46:01,860 --> 00:46:25,080
实际上

803
00:46:25,110 --> 00:46:27,440
KKT条件保证

804
00:46:27,490 --> 00:46:30,520
它们中至少有一个为0

805
00:46:30,620 --> 00:46:32,590
也有可能

806
00:46:32,680 --> 00:46:35,910
两项同时为0 但是在实际应用中

807
00:46:35,990 --> 00:46:37,830
当你求解最优化问题的时候

808
00:46:37,940 --> 00:46:41,140
你会发现  多数情况下

809
00:46:41,230 --> 00:46:45,120
α_i不等于0  当且仅当g_i (w^* )=0

810
00:46:45,200 --> 00:46:47,720
这个命题并不是严格正确的

811
00:46:47,810 --> 00:46:52,310
因为有可能这两项都为0 但是实际情况中

812
00:46:52,360 --> 00:46:53,800
当我们求解这样的问题时

813
00:46:53,910 --> 00:46:55,080
多数情况下

814
00:46:55,140 --> 00:46:57,510
它们中会有一个数非0

815
00:46:57,590 --> 00:47:01,120
当这个条件为真  即:

816
00:47:01,200 --> 00:47:06,250
g_i (w^* )=0时  我们说

817
00:47:06,350 --> 00:47:16,520
g_i是一个活动约束

818
00:47:16,640 --> 00:47:20,360
因为我们称一个约束为--

819
00:47:20,720 --> 00:47:21,860
我们的约束是g_i (w)

820
00:47:21,930 --> 00:47:23,150
一定小于等于0

821
00:47:23,240 --> 00:47:25,090
那么当它等于0时

822
00:47:25,170 --> 00:47:28,010
我们称这个约束为

823
00:47:28,080 --> 00:47:29,390
活动约束

824
00:47:29,480 --> 00:47:34,880
当我们讨论SVM的时候

825
00:47:34,960 --> 00:47:37,200
我们会回来

826
00:47:37,240 --> 00:47:39,120
扩展一下这个概念

827
00:47:40,300 --> 00:47:43,930
让我们换块黑板

828
00:47:44,020 --> 00:47:54,010
我们一会儿之后会再来看这块黑板  但是--

829
00:47:54,080 --> 00:48:09,200
让我们回去解决

830
00:48:09,290 --> 00:48:11,190
我们刚刚在解决的

831
00:48:11,560 --> 00:48:13,400
最优间隔分类器

832
00:48:13,490 --> 00:48:14,830
的最优化问题对应的

833
00:48:14,910 --> 00:48:16,210
原始问题和对偶问题

834
00:48:16,300 --> 00:48:18,380
首先我们在符号表示上有些变动

835
00:48:18,420 --> 00:48:22,050
一直以来

836
00:48:22,080 --> 00:48:23,740
在引出KKT条件的过程中

837
00:48:23,810 --> 00:48:31,810
我们一直认为拉格朗日乘数有两组:α_i 和β_i

838
00:48:31,910 --> 00:48:34,650
实际上当我们处理SVM问题时

839
00:48:34,730 --> 00:48:38,080
我们只需要一组

840
00:48:38,160 --> 00:48:41,860
拉格朗日乘数:α_i

841
00:48:41,920 --> 00:48:45,790
此外  当我在讲KKT条件时

842
00:48:45,890 --> 00:48:49,330
我用w表示

843
00:48:49,420 --> 00:48:51,470
我的原始优化问题的参数

844
00:48:51,550 --> 00:48:53,200
我希望最小化f(w)

845
00:48:53,310 --> 00:48:55,350
在我的第一个最优化问题中

846
00:48:55,420 --> 00:48:56,830
我希望最优化问题

847
00:48:56,910 --> 00:48:58,540
能够找到参数w

848
00:48:58,610 --> 00:49:00,960
而在SVM问题中

849
00:49:01,040 --> 00:49:03,800
我有两组参数

850
00:49:03,900 --> 00:49:05,530
w和b 所以

851
00:49:05,620 --> 00:49:10,700
你们需要记住这些符号变动

852
00:49:10,770 --> 00:49:17,280
我们之前讨论的问题中

853
00:49:17,340 --> 00:49:19,540
我希望最小化|(|w| )|^2

854
00:49:19,630 --> 00:49:22,060
出于约定的原因我在前面加上了一个1/2

855
00:49:22,140 --> 00:49:23,300
因为这样可以使我们推出的结果

856
00:49:23,380 --> 00:49:24,510
更加漂亮

857
00:49:24,620 --> 00:49:28,610
并且需要满足约束:

858
00:49:28,690 --> 00:49:35,230
y^i (w^T x^i+b)≥1

859
00:49:35,310 --> 00:49:43,420
基于这个约束

860
00:49:43,540 --> 00:49:47,150
我们要对它进行改写

861
00:49:47,250 --> 00:49:50,820
g_i (w  b)  记得之前我写的是g_i (w)

862
00:49:50,920 --> 00:49:53,600
但是现在我的参数是w和b

863
00:49:53,710 --> 00:50:03,620
所以g_i (w  b)被定义成这样的形式

864
00:50:03,730 --> 00:50:18,170
让我们再回过头来

865
00:50:18,280 --> 00:50:21,120
看一下KKT对偶互补性条件

866
00:50:21,200 --> 00:50:27,930
如果α_i=0

867
00:50:28,030 --> 00:50:36,710
这一定蕴含着:g_i (w  b)=0

868
00:50:36,810 --> 00:50:39,140
换句话说  这是一个活动约束

869
00:50:39,230 --> 00:50:48,480
这意味着什么呢?这意味着--

870
00:50:48,580 --> 00:50:54,900
实际上g_i (w  b)=0

871
00:50:54,990 --> 00:50:58,730
意味着训练样本(x_i  y_i)

872
00:50:58,820 --> 00:51:09,620
的函数间隔等于1

873
00:51:09,720 --> 00:51:13,910
因为约束规定

874
00:51:14,040 --> 00:51:17,630
每个样本的函数间隔

875
00:51:17,720 --> 00:51:19,420
都必须大于等于1

876
00:51:19,530 --> 00:51:21,130
所以如果它是一个活动约束

877
00:51:21,220 --> 00:51:22,740
那么它实际上是将不等式条件

878
00:51:22,840 --> 00:51:24,210
变成了等式条件

879
00:51:24,310 --> 00:51:25,660
这意味着我的训练样本i

880
00:51:25,710 --> 00:51:28,730
的函数间隔一定等于1

881
00:51:28,770 --> 00:51:34,440
所以--现在

882
00:51:34,540 --> 00:51:35,930
我需要换一块黑板

883
00:51:36,020 --> 00:52:01,050
它到底表示了什么可以用图展示一下

884
00:52:01,150 --> 00:52:04,400
你有一些训练样本

885
00:52:04,500 --> 00:52:12,160
和一个分隔超平面

886
00:52:12,260 --> 00:52:17,730
所以函数间隔为1

887
00:52:17,840 --> 00:52:22,740
的样本就是这些

888
00:52:22,860 --> 00:52:27,100
离超平面最近的样本

889
00:52:27,200 --> 00:52:33,290
这是我的等式

890
00:52:33,380 --> 00:52:37,740
在这个用图展示的例子中

891
00:52:37,830 --> 00:52:39,670
实际上

892
00:52:39,760 --> 00:52:49,770
只有这三个样本的

893
00:52:49,900 --> 00:52:53,870
函数间隔等于1

894
00:52:53,960 --> 00:52:56,960
所有其它离得较远的样本

895
00:52:57,010 --> 00:53:00,330
的函数间隔

896
00:53:00,390 --> 00:53:01,870
都严格的大于1

897
00:53:01,970 --> 00:53:10,380
这些函数间隔为1的样本

898
00:53:10,450 --> 00:53:22,010
所对应的

899
00:53:22,110 --> 00:53:24,910
拉格朗日乘数

900
00:53:25,010 --> 00:53:26,580
都不等于0 但是再强调一次

901
00:53:26,580 --> 00:53:27,710
这个结果不一定成立

902
00:53:27,820 --> 00:53:30,940
有可能g_i和α_i都等于0

903
00:53:31,010 --> 00:53:34,850
但是通常情况下  当g_i=0时  α_i通常会是非0的

904
00:53:34,930 --> 00:53:37,620
所以那些函数间隔

905
00:53:37,710 --> 00:53:38,920
等于1的样本

906
00:53:39,020 --> 00:53:40,880
就是那些α_i不等于0的样本

907
00:53:40,990 --> 00:53:48,400
一个有用的性质是

908
00:53:48,510 --> 00:53:50,670
从这张图可以看出

909
00:53:50,770 --> 00:53:52,430
通常情况下

910
00:53:52,540 --> 00:53:55,150
我们找到一个

911
00:53:55,250 --> 00:53:56,850
最优化问题的解

912
00:53:56,970 --> 00:53:59,170
可以发现只有很少数量的训练样本

913
00:53:59,260 --> 00:54:00,830
函数间隔等于1

914
00:54:00,930 --> 00:54:02,380
在我画的这张图中

915
00:54:02,460 --> 00:54:04,300
有三个样本

916
00:54:04,390 --> 00:54:05,680
的函数间隔等于1

917
00:54:05,800 --> 00:54:07,530
只有少量的样本

918
00:54:07,640 --> 00:54:09,930
到超平面的距离是最小距离

919
00:54:10,040 --> 00:54:13,170
这里只有三个

920
00:54:13,270 --> 00:54:15,950
样本的函数间隔等于1

921
00:54:16,060 --> 00:54:22,290
这些样本我们称之为支持向量

922
00:54:22,410 --> 00:54:28,290
支持向量机中的支持向量就是这个意思

923
00:54:28,370 --> 00:54:29,340
这三个

924
00:54:29,450 --> 00:54:31,140
函数间隔为1的训练样本

925
00:54:31,290 --> 00:54:32,640
我们称其为支持向量

926
00:54:32,740 --> 00:54:38,020
支持向量的数量很少

927
00:54:38,130 --> 00:54:40,240
这意味着通常情况下

928
00:54:40,330 --> 00:54:42,760
多数的α_i都等于0

929
00:54:42,870 --> 00:54:55,200
如果α_i=0

930
00:54:55,280 --> 00:55:01,920
那么其对应的样本就不是支持向量

931
00:55:01,920 --> 00:55:03,990
让我们继续

932
00:55:04,070 --> 00:55:07,760
求解最优化问题

933
00:55:20,720 --> 00:55:32,190
我们有一个最大间隔优化问题

934
00:55:32,300 --> 00:55:35,800
我将拉格朗日算子写出来

935
00:55:35,890 --> 00:55:41,500
由于我们只有不等式约束

936
00:55:41,580 --> 00:55:43,760
也就是g_i约束

937
00:55:43,860 --> 00:55:45,650
没有h_i约束

938
00:55:45,760 --> 00:55:47,750
我们只有不等式约束

939
00:55:47,810 --> 00:55:49,400
没有等式约束

940
00:55:49,500 --> 00:55:53,960
所以对于拉格朗日乘数  我们这里只有α

941
00:55:54,040 --> 00:55:56,090
而没有β

942
00:55:56,190 --> 00:56:04,560
我们的拉格朗日算子是

943
00:56:04,660 --> 00:56:18,410
这是我们的拉格朗日算子

944
00:56:18,520 --> 00:56:29,020
现在让我们看看它的对偶问题是什么

945
00:56:29,130 --> 00:56:30,350
为了完成这个工作

946
00:56:30,440 --> 00:56:32,340
我需要给出?_D (α)--

947
00:56:32,420 --> 00:56:34,150
这里没有β--

948
00:56:34,240 --> 00:56:37,920
所以?_D (α)应该等于

949
00:56:37,990 --> 00:56:43,060
min┬(w  b)?〖L(w  b  α)〗

950
00:56:43,150 --> 00:56:46,990
所以对偶问题是要使?_D最大

951
00:56:47,090 --> 00:56:48,110
作为α的函数

952
00:56:48,190 --> 00:56:50,050
我们需要搞清楚?_D是什么

953
00:56:50,150 --> 00:56:52,020
这样才能帮我们弄清对偶问题

954
00:56:52,120 --> 00:56:56,000
为了求出?_D

955
00:56:56,100 --> 00:56:57,350
需要怎么做呢?

956
00:56:57,440 --> 00:56:59,050
我们需要将拉格朗日算子

957
00:56:59,140 --> 00:57:02,500
看成w和b的函数  并使其最小化--

958
00:57:02,600 --> 00:57:03,510
应该怎样做呢?

959
00:57:03,590 --> 00:57:05,260
怎样使拉格朗日算子最小化呢?

960
00:57:05,370 --> 00:57:07,390
为了最小化拉格朗日算子

961
00:57:07,500 --> 00:57:10,410
(它是一个w和b的函数)  我们只需像往常那样

962
00:57:10,520 --> 00:57:12,290
我们对拉格朗日算子

963
00:57:12,370 --> 00:57:15,040
相对于w和b求偏导数

964
00:57:15,150 --> 00:57:16,290
并将其设为0

965
00:57:16,370 --> 00:57:18,030
这样我们可以求出w和b

966
00:57:18,110 --> 00:57:19,290
使拉格朗日算子最小化

967
00:57:19,410 --> 00:57:21,770
相对于w

968
00:57:21,860 --> 00:57:28,420
对拉格朗日算子求导 


969
00:57:28,550 --> 00:57:29,810
我这里直接把答案写出来

970
00:57:29,910 --> 00:57:31,640
你们应该知道怎样计算

971
00:57:31,750 --> 00:57:40,110
我需要使这个w的函数最小化

972
00:57:40,200 --> 00:57:42,200
所以我对w求导并将其设为0

973
00:57:42,200 --> 00:57:43,490
所以得到了这个结果

974
00:57:43,570 --> 00:57:56,480
这意味着w应该等于这个结果

975
00:57:56,600 --> 00:58:01,450
所以  w

976
00:58:01,550 --> 00:58:03,630
实际上是输入特征向量的

977
00:58:03,710 --> 00:58:05,650
线性组合

978
00:58:05,730 --> 00:58:08,670
这些是由α_i设定的权重

979
00:58:08,750 --> 00:58:10,880
乘以x_i之后的加和

980
00:58:10,990 --> 00:58:12,550
x_i是训练集合中的样本

981
00:58:12,660 --> 00:58:14,160
稍后我们会用到这个结果

982
00:58:14,270 --> 00:58:17,810
另外一个等式是--

983
00:58:17,910 --> 00:58:24,080
相对于b

984
00:58:24,170 --> 00:58:25,670
对拉格朗日算子求偏导  它等于

985
00:58:25,780 --> 00:58:32,860
这个式子

986
00:58:32,930 --> 00:58:36,740
我要让这项等于0

987
00:58:36,850 --> 00:58:38,980
这些是我的两个约束

988
00:58:39,060 --> 00:58:47,810
所以

989
00:58:47,900 --> 00:58:51,060
我现在要做的是

990
00:58:51,170 --> 00:58:53,260
我会用这两条约束

991
00:58:53,350 --> 00:58:54,990
我会用

992
00:58:55,090 --> 00:58:56,590
w的值

993
00:58:56,670 --> 00:59:02,070
我会用

994
00:59:02,160 --> 00:59:03,570
刚才求出的w的值

995
00:59:03,670 --> 00:59:07,670
代入到这里

996
00:59:07,780 --> 00:59:10,010
看看拉格朗日算子到底是什么

997
00:59:10,120 --> 00:59:12,370
当我相对于w使其最小化的时候

998
00:59:12,470 --> 00:59:16,200
我稍后再考虑b

999
00:59:16,250 --> 00:59:39,010
让我看看  拉格朗日算子等于

1000
00:59:39,130 --> 00:59:43,100
这个式子

1001
00:59:43,170 --> 01:00:00,380
第一项  w^T w

1002
01:00:00,490 --> 01:00:07,700
应该等于这一项

1003
01:00:07,810 --> 01:00:12,020
乘以这一项

1004
01:00:12,120 --> 01:00:22,830
这里我仅仅是将

1005
01:00:22,900 --> 01:00:23,950
之前的结果代入进来

1006
01:00:24,030 --> 01:00:27,400
因为这里是w^T w--

1007
01:00:27,510 --> 01:00:30,100
所以可以讲这个二次函数展开

1008
01:00:30,210 --> 01:00:34,030
并且将w代入到这里

1009
01:00:34,110 --> 01:01:23,970
我会得到这个结果 这里我使用

1010
01:01:24,070 --> 01:01:26,270
尖括号表示内积

1011
01:01:26,370 --> 01:01:30,760
这个部分的含义是内积

1012
01:01:30,830 --> 01:01:33,130
〖x^((i) )〗^T x^((j) )

1013
01:01:33,240 --> 01:01:37,720
第一项和第二项

1014
01:01:37,800 --> 01:01:39,970
实际上是相同的  除了系数之外

1015
01:01:40,070 --> 01:01:47,710
所以为了简化结果  它应该等于

1016
01:01:47,830 --> 01:02:20,520
让我们将这个式子称为W(α)

1017
01:02:20,620 --> 01:02:49,450
我们的对偶问题是这样的

1018
01:02:49,510 --> 01:02:52,950
我希望最大化W(α)

1019
01:02:53,050 --> 01:02:54,730
它是--

1020
01:02:54,810 --> 01:03:01,010
我应该告诉你们

1021
01:03:01,100 --> 01:03:02,670
我意识到符号用得有点乱

1022
01:03:02,770 --> 01:03:05,040
我用大写字母W(α)表示

1023
01:03:05,130 --> 01:03:06,900
我之前写的公式

1024
01:03:06,960 --> 01:03:10,690
而我用小写字母w

1025
01:03:10,770 --> 01:03:12,970
表示原始问题中的参数

1026
01:03:13,080 --> 01:03:15,040
w^T x^((i) )

1027
01:03:15,130 --> 01:03:17,760
所以大写的W和小写的w

1028
01:03:17,860 --> 01:03:22,010
意思是完全不同的  但是很不幸

1029
01:03:22,120 --> 01:03:23,440
据我所知  这种表示方法

1030
01:03:23,550 --> 01:03:24,860
是标准表示法

1031
01:03:24,940 --> 01:03:30,170
所以对偶问题是这样的

1032
01:03:30,260 --> 01:03:32,530
同时满足下列约束:

1033
01:03:32,640 --> 01:03:40,210
α_i≥0

1034
01:03:40,440 --> 01:03:43,170
∑_i?〖y_i α_i 〗=0

1035
01:03:43,280 --> 01:03:47,410
最后一个约束

1036
01:03:47,470 --> 01:03:50,640
是我在这里得到的

1037
01:03:50,710 --> 01:03:54,450
∑_i?〖y_i α_i 〗=0

1038
01:03:54,560 --> 01:03:56,300
这个约束是从这里得到的

1039
01:03:56,380 --> 01:04:04,170
让我--我记得前几年

1040
01:04:04,260 --> 01:04:05,950
我讲到这里的时候

1041
01:04:06,060 --> 01:04:08,020
这个约束总是

1042
01:04:08,070 --> 01:04:09,140
有些令人困惑

1043
01:04:09,250 --> 01:04:11,350
让我花两分钟

1044
01:04:11,440 --> 01:04:12,710
讲一下这个约束的含义

1045
01:04:12,820 --> 01:04:13,990
如果你们不明白

1046
01:04:14,080 --> 01:04:17,020
我想也没什么大不了的

1047
01:04:17,110 --> 01:04:20,560
当我相对于b

1048
01:04:20,670 --> 01:04:22,350
对拉格朗日算子求偏导时

1049
01:04:22,460 --> 01:04:25,240
我们得到了这个约束

1050
01:04:25,330 --> 01:04:26,530
∑_i?〖y_i α_i 〗=0

1051
01:04:26,630 --> 01:04:30,050
这里是关于这个约束的解释

1052
01:04:30,160 --> 01:04:38,510
如果∑_i?〖y_i α_i 〗不为0

1053
01:04:38,610 --> 01:04:56,850
那么?_D (w  b)--对不起

1054
01:04:56,930 --> 01:05:03,450
那么?_D (α)等于

1055
01:05:03,560 --> 01:05:09,520
负无穷

1056
01:05:09,610 --> 01:05:16,450
换句话说  我的拉格朗日算子

1057
01:05:16,540 --> 01:05:19,220
是参数b的线性函数

1058
01:05:19,330 --> 01:05:21,060
所以我们对

1059
01:05:21,170 --> 01:05:22,470
我们之前求出的约束的解释是

1060
01:05:22,570 --> 01:05:25,020
如果∑_i?〖y_i α_i 〗不为0

1061
01:05:25,110 --> 01:05:27,860
那么?_D (α)等于负无穷

1062
01:05:27,960 --> 01:05:32,580
所以如果你的目标是

1063
01:05:32,670 --> 01:05:37,700
要使?_D (α)最大化

1064
01:05:37,760 --> 01:05:40,330
那么你应该选择α

1065
01:05:40,420 --> 01:05:42,920
使得∑_i?〖y_i α_i 〗=0

1066
01:05:43,000 --> 01:05:47,550
当∑_i?〖y_i α_i 〗=0时

1067
01:05:47,660 --> 01:06:02,580
?_D (α)=W(α)

1068
01:06:02,680 --> 01:06:05,450
这就是为什么

1069
01:06:05,550 --> 01:06:08,900
我们在选择最大化W(α)的同时

1070
01:06:09,000 --> 01:06:10,590
要保证约束:∑_i?〖y_i α_i 〗=0

1071
01:06:10,670 --> 01:06:16,300
不幸的是

1072
01:06:16,420 --> 01:06:19,460
这个条件在

1073
01:06:19,550 --> 01:06:20,920
推出对偶问题的过程中

1074
01:06:21,020 --> 01:06:23,360
又增加了额外的一些符号表示 顺便说一句

1075
01:06:23,460 --> 01:06:25,560
所有优化问题

1076
01:06:25,680 --> 01:06:27,620
都是针对w进行的

1077
01:06:27,700 --> 01:06:33,620
b仅仅是一个参数 让我看看

1078
01:06:33,710 --> 01:06:46,460
有问题吗?很好

1079
01:06:46,550 --> 01:06:51,350
在推出对偶优化问题的过程中

1080
01:06:51,440 --> 01:06:53,210
你们不需要太在意这些

1081
01:06:53,310 --> 01:06:55,340
如果你们不是很明白也不用担心

1082
01:06:55,410 --> 01:06:57,860
这个约束条件

1083
01:06:57,940 --> 01:06:59,180
是之前我们求出来的

1084
01:06:59,260 --> 01:07:00,750
我们对b求偏导数

1085
01:07:00,840 --> 01:07:03,180
之后得到了这个约束

1086
01:07:03,270 --> 01:07:06,460
我仅仅将求出的结果放在了这里

1087
01:07:06,580 --> 01:07:08,900
我们继续来看这个对偶优化问题

1088
01:07:08,950 --> 01:07:12,890
我们用来推出

1089
01:07:12,980 --> 01:07:15,330
SVM的最优间隔分类器

1090
01:07:15,420 --> 01:07:17,220
的方法是

1091
01:07:17,310 --> 01:07:21,070
我们会解决这个对偶优化问题

1092
01:07:21,170 --> 01:07:22,850
求出参数α^

1093
01:07:22,940 --> 01:07:31,720
如果你愿意  你可以--

1094
01:07:31,820 --> 01:07:34,260
这是我在之前黑板上

1095
01:07:34,340 --> 01:07:35,340
写的等式

1096
01:07:35,420 --> 01:07:38,300
我们说w应该等于

1097
01:07:38,390 --> 01:07:45,270
这个式子

1098
01:07:45,340 --> 01:07:48,750
所以一旦你求出了α

1099
01:07:48,850 --> 01:07:53,490
你可以将其代入从而很快地求出w

1100
01:07:53,600 --> 01:07:55,060
也就是我们之前提出的

1101
01:07:55,140 --> 01:07:56,370
原始问题的参数

1102
01:07:56,450 --> 01:08:01,940
一旦你求出了α和w

1103
01:08:02,030 --> 01:08:05,390
你可以回过头来--

1104
01:08:05,450 --> 01:08:06,690
一旦你求出了α和w

1105
01:08:06,750 --> 01:08:10,180
你可以很容易地求出b

1106
01:08:10,240 --> 01:08:12,140
b的意思是

1107
01:08:12,240 --> 01:08:14,710
给定一组训练集合

1108
01:08:14,790 --> 01:08:17,420
如果你找到了w

1109
01:08:17,500 --> 01:08:18,660
那么你就确定了

1110
01:08:18,780 --> 01:08:20,560
你的超平面的方向

1111
01:08:20,640 --> 01:08:22,930
你知道应该是这些平面之一

1112
01:08:23,030 --> 01:08:26,970
你现在已经知道了

1113
01:08:27,030 --> 01:08:28,060
超平面的方向

1114
01:08:28,150 --> 01:08:29,060
你现在只需要决定

1115
01:08:29,130 --> 01:08:31,520
使用哪个超平面就可以了

1116
01:08:31,550 --> 01:08:32,750
这就是求解b的方法

1117
01:08:32,840 --> 01:08:34,700
所以一旦你求出了α和w

1118
01:08:34,760 --> 01:08:36,100
你可以很容易地求出b

1119
01:08:36,180 --> 01:08:38,660
你可以将

1120
01:08:38,750 --> 01:08:50,680
α和w代入原始优化问题中求解b

1121
01:08:50,760 --> 01:09:03,520
出于完整性的考虑

1122
01:09:03,600 --> 01:09:06,810
我还是将它写下来  但是--

1123
01:09:06,900 --> 01:09:32,040
对于这个公式的直观理解是

1124
01:09:32,140 --> 01:09:38,790
找到最差的正样本

1125
01:09:38,840 --> 01:09:40,200
和最差的负样本

1126
01:09:40,390 --> 01:09:43,170
比如说这个样本和这个样本

1127
01:09:43,260 --> 01:09:44,370
根据它们的位置

1128
01:09:44,450 --> 01:09:45,570
你可以知道

1129
01:09:45,650 --> 01:09:47,320
应该将超平面

1130
01:09:47,420 --> 01:09:49,380
放置在哪里

1131
01:09:49,480 --> 01:09:56,290
这是最优间隔分类器

1132
01:09:56,370 --> 01:09:58,020
也被称为支持向量机

1133
01:09:58,130 --> 01:10:00,630
如果你不用另外一个概念

1134
01:10:00,720 --> 01:10:01,990
"核"来表示它的话

1135
01:10:02,090 --> 01:10:03,090
关于这个我只会讲一点

1136
01:10:03,170 --> 01:10:06,050
我希望这个过程足够清晰

1137
01:10:06,130 --> 01:10:07,180
这是一个对偶问题

1138
01:10:07,250 --> 01:10:08,510
我们要解决对偶问题

1139
01:10:08,590 --> 01:10:09,730
求出α_i

1140
01:10:09,820 --> 01:10:12,130
并求出w和b

1141
01:10:12,250 --> 01:10:17,400
我还要讲一个东西

1142
01:10:17,490 --> 01:10:21,120
可以为下节课起个头

1143
01:10:21,210 --> 01:10:24,280
我想我又得将这个公式写出来了

1144
01:10:24,360 --> 01:10:30,290
实际上

1145
01:10:30,370 --> 01:10:32,720
我们可以将

1146
01:10:32,820 --> 01:10:34,980
整个算法表示成

1147
01:10:35,070 --> 01:10:36,810
内积的形式

1148
01:10:36,890 --> 01:10:38,180
我的意思是这样的

1149
01:10:38,290 --> 01:10:41,510
参数w

1150
01:10:41,580 --> 01:10:43,870
是输入样本之和

1151
01:10:43,980 --> 01:10:47,250
你需要进行预测

1152
01:10:47,350 --> 01:10:51,060
给定一个x作为输入

1153
01:10:51,150 --> 01:10:52,240
你希望根据x的值

1154
01:10:52,330 --> 01:10:53,450
输出x的假设

1155
01:10:53,540 --> 01:10:57,390
这个可以由g(w^T x+b)给出

1156
01:10:57,490 --> 01:11:00,390
g的输出

1157
01:11:00,480 --> 01:11:01,320
只能为-1或1

1158
01:11:01,400 --> 01:11:05,280
所以你希望计算w^T x+b

1159
01:11:05,370 --> 01:11:12,790
它应该等于这个

1160
01:11:12,890 --> 01:11:21,290
它可以贝表示为

1161
01:11:21,390 --> 01:11:23,620
新输入的x

1162
01:11:23,720 --> 01:11:27,020
和你的训练样本的

1163
01:11:27,110 --> 01:11:28,270
内积之和

1164
01:11:28,350 --> 01:11:35,240
这个概念可以帮我们引出下一讲

1165
01:11:35,330 --> 01:11:36,630
也就是核

1166
01:11:36,730 --> 01:11:40,850
实际上

1167
01:11:40,970 --> 01:11:43,160
在SVM的

1168
01:11:43,240 --> 01:11:44,440
特征向量空间中

1169
01:11:44,530 --> 01:11:47,250
有的时候你的训练样本

1170
01:11:47,340 --> 01:11:48,890
的维数将会非常高

1171
01:11:48,980 --> 01:11:55,530
甚至有可能

1172
01:11:55,610 --> 01:11:57,620
你要用到的特征向量

1173
01:11:57,670 --> 01:12:00,850
是无限维的向量

1174
01:12:00,910 --> 01:12:06,830
事实证明

1175
01:12:06,920 --> 01:12:11,750
这是一种有趣的表示方法

1176
01:12:11,860 --> 01:12:13,830
你可以用它

1177
01:12:13,910 --> 01:12:17,060
来高效地计算内积

1178
01:12:17,160 --> 01:12:27,870
这个结论仅对一些特定的特征空间成立

1179
01:12:27,980 --> 01:12:29,830
对任意的特征空间它未必成立

1180
01:12:29,940 --> 01:12:32,450
但是当下一讲

1181
01:12:32,560 --> 01:12:34,610
我们讲到核的概念时

1182
01:12:34,690 --> 01:12:38,180
我们可以看到一些例子

1183
01:12:38,260 --> 01:12:39,780
你有非常高维的特征向量

1184
01:12:39,890 --> 01:12:40,710
你可以计算--

1185
01:12:40,800 --> 01:12:43,630
你不肯能将x^((i) )显式地表示出来

1186
01:12:43,730 --> 01:12:45,440
因为x^((i) )是

1187
01:12:45,450 --> 01:12:46,380
无限维的向量

1188
01:12:46,480 --> 01:12:47,910
你甚至无法将其完全放入内存

1189
01:12:48,020 --> 01:12:49,640
但是你仍然能够

1190
01:12:49,730 --> 01:12:51,100
高效地计算不同

1191
01:12:51,200 --> 01:12:53,260
特征向量的内积

1192
01:12:53,370 --> 01:12:55,710
所以你可以

1193
01:12:55,800 --> 01:12:56,780
利用这些内积

1194
01:12:56,860 --> 01:12:58,250
进行预测

1195
01:12:58,330 --> 01:13:05,130
这一项就是(x^((i) ) )^T x

1196
01:13:05,240 --> 01:13:06,950
你可以非常高效地计算这些内积

1197
01:13:07,020 --> 01:13:08,500
并作出预测

1198
01:13:08,580 --> 01:13:10,080
此外

1199
01:13:10,180 --> 01:13:12,780
我们推出对偶问题的其它的原因是

1200
01:13:12,860 --> 01:13:15,330
在这块黑板上

1201
01:13:15,430 --> 01:13:17,480
当我推出W(α)的时候

1202
01:13:17,570 --> 01:13:20,290
W(α)具有同样性质--

1203
01:13:20,380 --> 01:13:23,840
这里又一次

1204
01:13:23,950 --> 01:13:25,200
写成了内积的形式

1205
01:13:25,290 --> 01:13:30,410
如果你看一下

1206
01:13:30,500 --> 01:13:32,400
整个对偶优化问题

1207
01:13:32,500 --> 01:13:33,750
并且仔细观察算法的每个步骤

1208
01:13:33,860 --> 01:13:36,040
你会发现  你做的每一件事

1209
01:13:36,130 --> 01:13:37,500
学习参数α

1210
01:13:37,590 --> 01:13:39,530
假设你在优化问题中

1211
01:13:39,620 --> 01:13:40,660
需要求参数α

1212
01:13:40,740 --> 01:13:42,150
你会发现你做的每一件事

1213
01:13:42,260 --> 01:13:45,170
都不需要直接地将x_i表示出来

1214
01:13:45,260 --> 01:13:46,720
你只需要

1215
01:13:46,800 --> 01:13:48,370
像这样计算

1216
01:13:48,480 --> 01:13:49,610
特征向量的内积

1217
01:13:49,730 --> 01:13:55,270
关于这个算法的

1218
01:13:55,380 --> 01:13:59,970
最后一个漂亮的性质是--我之前说过

1219
01:14:00,090 --> 01:14:03,600
只有那些和支持向量

1220
01:14:03,690 --> 01:14:06,870
对应的α_i不等于0

1221
01:14:06,980 --> 01:14:08,300
也就是和那些函数间隔

1222
01:14:08,300 --> 01:14:09,890
等于1的向量对应的α_i

1223
01:14:09,970 --> 01:14:12,650
实际上  它们的数量非常少

1224
01:14:12,730 --> 01:14:15,090
这意味着

1225
01:14:15,180 --> 01:14:16,630
如果你用这种方式表示w

1226
01:14:16,720 --> 01:14:19,760
那么w

1227
01:14:19,870 --> 01:14:22,240
仅仅依赖于很少一部分训练样本

1228
01:14:22,340 --> 01:14:24,900
因为对于大多数的训练样本来说  α_i=0

1229
01:14:25,010 --> 01:14:28,150
所以这里当你进行求和时

1230
01:14:28,220 --> 01:14:30,390
你只需要为那些支持向量

1231
01:14:30,500 --> 01:14:31,610
计算内积

1232
01:14:31,680 --> 01:14:34,530
它们只占整个训练集合的很小的比重

1233
01:14:34,630 --> 01:14:36,030
这是另外一个漂亮的性质

1234
01:14:36,130 --> 01:14:37,710
因为大多数的α_i等于0

1235
01:14:37,810 --> 01:14:42,270
当我们下节课讲到核的时候

1236
01:14:42,380 --> 01:14:43,580
这些概念你们会更清楚

1237
01:14:43,670 --> 01:14:48,280
在下课之前还有什么问题吗?什么?

1238
01:14:48,360 --> 01:14:50,120
似乎到目前为止

1239
01:14:50,220 --> 01:14:51,090
我们所做的工作中

1240
01:14:51,180 --> 01:14:52,410
样本数据都非常好

1241
01:14:52,490 --> 01:14:53,990
如果样本数据不是很好导致

1242
01:14:53,990 --> 01:14:55,740
无法将它们完全分开该怎么办?

1243
01:14:55,850 --> 01:14:57,880
好的

1244
01:14:57,990 --> 01:14:59,550
对于今天所讲的内容

1245
01:14:59,640 --> 01:15:01,190
数据都是线性可分隔的

1246
01:15:01,300 --> 01:15:02,960
你可以用一个线性超平面将其完全分开

1247
01:15:03,050 --> 01:15:05,880
在下一讲我会修正这个假设

1248
01:15:05,980 --> 01:15:10,290
对这节课来说  这个假设没问题 什么?

1249
01:15:10,380 --> 01:15:11,680
我们不能假设--

1250
01:15:11,770 --> 01:15:17,870
【听不清】

1251
01:15:17,970 --> 01:15:19,240
是的

1252
01:15:19,330 --> 01:15:21,130
实际上有方法将这个算法

1253
01:15:21,240 --> 01:15:22,520
推广到多个类的情形

1254
01:15:22,620 --> 01:15:23,800
不过我应该不会在课上讲

1255
01:15:23,890 --> 01:15:25,950
这样的推广可能非常复杂

1256
01:15:26,050 --> 01:15:27,860
好的  今天就到这里

1257
01:15:27,970 --> 01:15:29,650
我们会在下节课中讲核

