1
00:00:10,560 --> 00:00:21,020
让我们来看看

2
00:00:21,180 --> 00:00:25,210
好了 所以 欢迎回来

3
00:00:25,320 --> 00:00:28,890
让我们今天继续

4
00:00:29,000 --> 00:00:31,140
强化学习算法的讨论

5
00:00:31,240 --> 00:00:34,110
我想要做的第一件事情

6
00:00:34,230 --> 00:00:36,720
其实是谈一点点

7
00:00:36,820 --> 00:00:38,860
调试强化学习算法

8
00:00:38,940 --> 00:00:42,010
然后我将继续上周的技术性讨论上的

9
00:00:42,100 --> 00:00:44,740
LQR线性二次型调节

10
00:00:44,850 --> 00:00:46,040
特别是

11
00:00:46,150 --> 00:00:47,770
我要告诉你一个称为

12
00:00:47,880 --> 00:00:48,710
french动态规划算法

13
00:00:48,820 --> 00:00:50,860
我认为这实际上是一个非常有效的

14
00:00:50,970 --> 00:00:54,570
绝对控制许多问题的

15
00:00:54,680 --> 00:00:55,980
强化学习算法

16
00:00:56,130 --> 00:00:57,890
然后 我们将谈论滤波(Kalman filters)

17
00:00:57,990 --> 00:01:00,050
和线性二次高斯控制 LGG

18
00:01:00,200 --> 00:01:03,010
让我们从调试RL算法开始

19
00:01:03,120 --> 00:01:05,820
我可以切换到笔记本电脑的显示器吗?

20
00:01:05,930 --> 00:01:19,150
这实际上是--我将要在这里做的是

21
00:01:19,260 --> 00:01:23,430
这是一个我之前讲过的特殊的例子

22
00:01:23,540 --> 00:01:25,150
但是我要再做一次

23
00:01:25,250 --> 00:01:28,080
所以 记住 你懂的 它是什么?

24
00:01:28,190 --> 00:01:29,680
大致在课程一半的时候

25
00:01:29,790 --> 00:01:33,820
我在演讲中讲过调试学习算法 对不?

26
00:01:33,930 --> 00:01:34,460
这个想法

27
00:01:34,560 --> 00:01:37,440
很多时候你运行一个学习算法

28
00:01:37,540 --> 00:01:39,520
你懂的 它也许大概不是你想的

29
00:01:39,620 --> 00:01:41,510
你希望的那样去做

30
00:01:41,650 --> 00:01:43,610
然后下一步你会怎么做?

31
00:01:43,710 --> 00:01:45,750
谈这个想法 你懂的

32
00:01:45,860 --> 00:01:47,810
一些在机器学习真的很不错的人

33
00:01:47,920 --> 00:01:50,170
人们真正能理解学习算法

34
00:01:50,270 --> 00:01:51,870
他们真的擅长让这些东西处理好

35
00:01:51,970 --> 00:01:56,300
很多时候 他们真正搞清楚为什么

36
00:01:56,440 --> 00:01:58,400
一个学习算法是能处理好或不能处理好

37
00:01:58,510 --> 00:02:03,120
以防止他们处理6个月

38
00:02:03,230 --> 00:02:06,530
而别人也许可以 只是看和说

39
00:02:06,630 --> 00:02:09,590
"啧 收集更多的训练数据是没有意义的

40
00:02:09,700 --> 00:02:12,200
因为你的学习算法有很高的偏差

41
00:02:12,310 --> 00:02:13,310
而不是高方差

42
00:02:13,430 --> 00:02:15,270
你花了6个月收集更多的训练数据

43
00:02:15,410 --> 00:02:16,850
因此 我可以告诉你6个月前

44
00:02:16,940 --> 00:02:17,880
这是浪费时间 对不对?

45
00:02:17,990 --> 00:02:19,640
所以这些类型的东西

46
00:02:19,720 --> 00:02:21,050
一些人是真的擅长机器学习

47
00:02:21,170 --> 00:02:23,020
他们真正懂的机器学习

48
00:02:23,150 --> 00:02:24,400
是非常擅长的

49
00:02:24,540 --> 00:02:29,180
好了 看看我的一些幻灯片

50
00:02:29,290 --> 00:02:32,040
我实际上不会谈这些幻灯片

51
00:02:32,180 --> 00:02:34,140
但这些正是你上一次看到的相同的幻灯片

52
00:02:34,240 --> 00:02:37,730
其实 让我就跳过前面的 我猜

53
00:02:37,870 --> 00:02:45,640
所以你上一次看到这个讨论 --对的

54
00:02:45,780 --> 00:02:47,560
你是否发生偏差问题

55
00:02:47,700 --> 00:02:49,050
或方差问题

56
00:02:49,190 --> 00:02:52,480
或在其他情况下--

57
00:02:52,580 --> 00:02:54,450
优化算法是收敛的

58
00:02:54,550 --> 00:02:56,650
或是否它[听不清]优化目标等

59
00:02:56,760 --> 00:02:58,610
同时 我们将再次讨论它

60
00:02:58,760 --> 00:03:01,640
但我再次承诺展示的一个例子是

61
00:03:01,780 --> 00:03:03,470
实际上是一个强化学习的例子

62
00:03:03,580 --> 00:03:06,470
但当时我们还

63
00:03:06,580 --> 00:03:07,580
没有谈到强化学习

64
00:03:07,680 --> 00:03:09,380
所以我答应做的同样的例子

65
00:03:09,480 --> 00:03:10,430
好吗?

66
00:03:10,540 --> 00:03:11,730
那么 开始我们的例子

67
00:03:11,840 --> 00:03:16,730
激励例子是机器人控制

68
00:03:16,830 --> 00:03:18,370
让我们来看看 写--比方说

69
00:03:18,510 --> 00:03:21,870
你要为这架直升机设计一个控制器

70
00:03:21,980 --> 00:03:26,220
因此 这是一个非常典型的方式

71
00:03:26,360 --> 00:03:29,200
你可能应用机器学习算法或

72
00:03:29,350 --> 00:03:32,520
几个机器学习算法 对于控制问题 对不?

73
00:03:32,630 --> 00:03:35,090
这是你可以先建立一个模拟器--

74
00:03:35,230 --> 00:03:37,580
控制问题是

75
00:03:37,690 --> 00:03:40,020
你要建立一个控制器

76
00:03:40,160 --> 00:03:41,850
使直升机在原地盘旋 对不?

77
00:03:41,960 --> 00:03:43,630
所以你想要做的第一件事情是

78
00:03:43,770 --> 00:03:45,200
建立一个直升机模拟器

79
00:03:45,300 --> 00:03:49,260
而这只是意味着模型状态转移概率

80
00:03:49,370 --> 00:03:51,810
一个直升机的P_SA(原英文字幕错误)

81
00:03:51,910 --> 00:03:54,020
你可以用许多不同的方式来处理

82
00:03:54,130 --> 00:03:56,250
也许你可以尝试阅读直升机教科书

83
00:03:56,360 --> 00:03:58,150
并且在已知直升机空气动力学的基础上

84
00:03:58,290 --> 00:04:01,070
建立模拟器

85
00:04:01,170 --> 00:04:02,620
它实际上这是很难处理的

86
00:04:02,760 --> 00:04:04,300
另一个你可以做的事情是收集数据

87
00:04:04,450 --> 00:04:06,020
也许适合线性模型

88
00:04:06,160 --> 00:04:07,620
或者适合非线性模型

89
00:04:07,760 --> 00:04:12,230
下一阶段是当前状态

90
00:04:12,370 --> 00:04:13,360
和当前操作的函数 对不?

91
00:04:13,470 --> 00:04:14,850
因此 有不同的方式

92
00:04:14,950 --> 00:04:16,420
来估计状态转移概率

93
00:04:16,530 --> 00:04:18,500
所以 现在 你现在有一个模拟器

94
00:04:18,640 --> 00:04:21,610
我显示了我们的模拟器的屏幕截图

95
00:04:21,720 --> 00:04:23,820
我们在右上角有一个适合有位置

96
00:04:23,930 --> 00:04:26,500
你可能会做的第二件事情是

97
00:04:26,640 --> 00:04:27,990
然后选择一个奖励函数

98
00:04:28,140 --> 00:04:30,160
因此 你可能会选择这种二次COS函数

99
00:04:30,270 --> 00:04:30,960
对不?

100
00:04:31,100 --> 00:04:33,620
所以在状态S(原文X)的奖励将

101
00:04:33,730 --> 00:04:36,490
是负的当前的状态和一些你的奖励函数的一

102
00:04:36,590 --> 00:04:38,640
个简单的例子理想状态的差的常模(屏幕上

103
00:04:38,780 --> 00:04:41,060
的公式)

104
00:04:41,160 --> 00:04:44,360
而这个 二次奖励函数 是我们已经在上一

105
00:04:44,470 --> 00:04:48,030
讲的LQR控制

106
00:04:48,170 --> 00:04:49,710
线性二次调节控制中使用的

107
00:04:49,850 --> 00:04:51,440
最后 对不?

108
00:04:51,590 --> 00:04:55,650
模型中的随机强化学习算法

109
00:04:55,790 --> 00:04:58,570
这意味着你使用的动态模型

110
00:04:58,710 --> 00:05:02,360
试图化最终的奖励边界总和

111
00:05:02,540 --> 00:05:05,270
当你这样做 你获得了政策

112
00:05:05,380 --> 00:05:09,300
我要去调用政策π下标RL

113
00:05:09,400 --> 00:05:11,980
表示强化学习算法的政策输出

114
00:05:12,060 --> 00:05:12,800
OK?

115
00:05:12,880 --> 00:05:17,730
比方说 你这样做

116
00:05:17,810 --> 00:05:22,200
导致控制器比你为直升机聘请的飞行员

117
00:05:22,270 --> 00:05:23,550
处理得更糟糕

118
00:05:23,610 --> 00:05:27,730
那么你如何去找出下一步该怎么做呢?

119
00:05:27,810 --> 00:05:29,390
嗯 实际上 你有几件事情你可能会做

120
00:05:29,470 --> 00:05:30,240
对不?

121
00:05:30,380 --> 00:05:32,190
你可能会尝试改进模拟器

122
00:05:32,300 --> 00:05:33,800
所以恰好有三个步骤

123
00:05:33,880 --> 00:05:34,870
你想说

124
00:05:34,950 --> 00:05:36,740
也许从直升机动力学新模式中

125
00:05:36,850 --> 00:05:39,000
但我觉得它是非--它实际上是非线性的

126
00:05:39,080 --> 00:05:41,290
或者 也许你要收集更多的训练数据

127
00:05:41,360 --> 00:05:43,070
这样你可以得到一个更好的

128
00:05:43,200 --> 00:05:46,570
直升机转移概率估计

129
00:05:46,660 --> 00:05:49,970
或者 也许你想摆弄

130
00:05:50,080 --> 00:05:52,130
直升机动态模型的特征

131
00:05:52,230 --> 00:05:53,880
对不?

132
00:05:53,980 --> 00:05:55,750
其他的事情你可以做的是

133
00:05:55,850 --> 00:05:57,470
你可以修改奖励函数R 如果你认为

134
00:05:57,570 --> 00:05:59,510
你懂的 它不只是一个二次函数

135
00:05:59,610 --> 00:06:00,660
也许是别的东西

136
00:06:00,770 --> 00:06:01,520
我不知道

137
00:06:01,630 --> 00:06:03,110
或者 也许你不满意

138
00:06:03,220 --> 00:06:04,150
这个强化学习算法

139
00:06:04,220 --> 00:06:05,210
也许你觉得 你知道

140
00:06:05,280 --> 00:06:07,010
该算法是处理地不太正确

141
00:06:07,110 --> 00:06:08,910
或者 也许你认为你需要

142
00:06:09,050 --> 00:06:10,690
更精细地描述状态

143
00:06:10,800 --> 00:06:13,330
以适用于你的强化学习算法

144
00:06:13,440 --> 00:06:15,590
或者 也许你需要摆弄

145
00:06:15,670 --> 00:06:16,940
价值函数逼近中的特征

146
00:06:17,020 --> 00:06:17,960
OK?

147
00:06:18,040 --> 00:06:21,200
所以这里有三个你可以做的例子

148
00:06:21,270 --> 00:06:25,810
再次 很多时候 如果你选择了一个错误的

149
00:06:25,920 --> 00:06:27,090
算法 你可以很容易花时间 你知道--

150
00:06:27,160 --> 00:06:29,710
其实这我不想说6个月

151
00:06:29,820 --> 00:06:31,110
你可以很容易花一年或两年的时间

152
00:06:31,250 --> 00:06:32,780
在错误的事情上

153
00:06:32,930 --> 00:06:34,670
嘿 Dan 帮个忙

154
00:06:34,780 --> 00:06:37,570
我粉笔快用完了 你可以四处找找

155
00:06:37,650 --> 00:06:40,080
帮我取些吗?谢谢

156
00:06:40,190 --> 00:06:44,160
所以团队做了三件事情

157
00:06:44,260 --> 00:06:46,720
他们会把黄色框复制到本幻灯片右上角

158
00:06:46,820 --> 00:06:48,900
你能做些什么呢?

159
00:06:49,000 --> 00:06:51,440
因此 这是 有点

160
00:06:51,550 --> 00:06:52,490
所以我们实际上是

161
00:06:52,590 --> 00:06:53,960
往往通过对直升机项目

162
00:06:54,110 --> 00:06:56,340
并决定如何处理

163
00:06:56,450 --> 00:07:00,770
因此 让我慢点进入这个例子

164
00:07:00,910 --> 00:07:03,330
所以这个有点 理由你可能通过

165
00:07:03,430 --> 00:07:07,690
假设这三个假设成立 对的?

166
00:07:07,800 --> 00:07:10,800
假设直升机模拟器是准确的

167
00:07:10,910 --> 00:07:12,700
所以让我们假设你建立了

168
00:07:12,850 --> 00:07:14,590
一个精确的动态模型

169
00:07:14,740 --> 00:07:18,290
假设

170
00:07:18,400 --> 00:07:19,380
我翻转到两个下面的幻灯片

171
00:07:19,490 --> 00:07:20,900
所以假设强化学习算法

172
00:07:21,050 --> 00:07:25,340
正确的控制了仿真直升机

173
00:07:25,450 --> 00:07:28,360
因此 最大化预期回报 对不?

174
00:07:28,500 --> 00:07:31,790
并假设预期收益最大化

175
00:07:31,930 --> 00:07:33,620
对应于自主飞行 对不?

176
00:07:33,720 --> 00:07:36,520
如果所有这三个假设成立

177
00:07:36,630 --> 00:07:40,000
那么这意味着你将了解到

178
00:07:40,110 --> 00:07:42,930
控制器π下标RL

179
00:07:43,070 --> 00:07:46,630
能让真实直升机飞行地很好 对不?

180
00:07:46,810 --> 00:07:52,190
因此 这是--我 给你们展示

181
00:07:52,290 --> 00:07:55,460
我经过时 我试图提出

182
00:07:55,560 --> 00:07:57,450
这个问题的诊断推理的根源

183
00:07:57,590 --> 00:07:59,940
因此 这些都是一些

184
00:08:00,080 --> 00:08:01,830
我们日常实际使用的

185
00:08:01,940 --> 00:08:03,870
各种改进控制问题的诊断学

186
00:08:03,980 --> 00:08:11,510
所以π下标RL 对不?

187
00:08:11,640 --> 00:08:13,950
我们说 它实际上让直升机飞行得不好

188
00:08:14,050 --> 00:08:17,710
所以 你要运行的第一个诊断

189
00:08:17,820 --> 00:08:19,480
就是检查它是否在模拟中飞行得很好

190
00:08:19,630 --> 00:08:20,690
好的?

191
00:08:20,830 --> 00:08:22,480
因此 如果在模拟中飞行得很好

192
00:08:22,620 --> 00:08:23,810
但在现实生活中飞行得不好

193
00:08:23,950 --> 00:08:27,580
那么问题是出在模拟器上 对不?

194
00:08:27,720 --> 00:08:30,290
由于模拟器预测你的控制器

195
00:08:30,390 --> 00:08:32,190
π下标RL 飞行得很好

196
00:08:32,270 --> 00:08:33,930
但它不会在现实生活中实际飞行得很好

197
00:08:34,040 --> 00:08:35,620
因此 如果成立

198
00:08:35,700 --> 00:08:38,120
那么表明 问题是出在模拟器上

199
00:08:38,220 --> 00:08:39,220
有问题吗?

200
00:08:39,330 --> 00:08:42,280
学生:[听不清]

201
00:08:42,350 --> 00:08:45,400
直升机飞行员尝试在模拟器上飞行?

202
00:08:45,500 --> 00:08:52,210
你有没有真正的直升机飞行员

203
00:08:52,290 --> 00:08:54,060
试图在模拟器上飞行呢?

204
00:08:54,170 --> 00:08:55,250
教导员(安德鲁吴):

205
00:08:55,330 --> 00:08:57,740
我尝试真正的直升机飞行模拟器?

206
00:08:57,840 --> 00:08:59,260
学生:真正的直升机飞行员

207
00:08:59,360 --> 00:09:00,290
讲师(安德鲁吴):哦 我明白

208
00:09:00,390 --> 00:09:02,020
我们要求直升机飞行员在模拟中飞行吗?

209
00:09:02,130 --> 00:09:03,780
所以 是的

210
00:09:03,920 --> 00:09:07,840
事实证明 后来的诊断中 你能做到这一点

211
00:09:07,940 --> 00:09:12,000
我们的项目中 我们通常不会那么做

212
00:09:12,100 --> 00:09:14,360
我们非正式地问飞行员

213
00:09:14,460 --> 00:09:16,630
他是世界上最好的飞行员之一

214
00:09:16,740 --> 00:09:20,900
Gary Zoco 有时看看模拟器

215
00:09:21,000 --> 00:09:23,180
我们不经常要他飞行模拟器

216
00:09:23,310 --> 00:09:28,060
回答你的问题

217
00:09:28,160 --> 00:09:29,920
但是 让我开始 并且告诉你一些你可能会

218
00:09:30,030 --> 00:09:32,520
使用的其他的诊断法 Ok?

219
00:09:32,660 --> 00:09:37,570
二是让我用π下标human(π_human)

220
00:09:37,720 --> 00:09:39,700
表示人类的控制政策 好的?

221
00:09:39,840 --> 00:09:42,460
这是π_human是一个策略 你懂的

222
00:09:42,570 --> 00:09:44,040
是人类执行的政策

223
00:09:44,180 --> 00:09:49,560
所以做的一件事情是比较π RL的值

224
00:09:49,670 --> 00:09:53,310
和π_human的值 OK?

225
00:09:53,410 --> 00:09:55,160
那么这真正的意思是

226
00:09:55,300 --> 00:09:58,360
看看直升机做了什么

227
00:09:58,500 --> 00:10:01,320
当它在π RL的控制下飞行时

228
00:10:01,460 --> 00:10:03,800
当它在人类飞行员

229
00:10:03,940 --> 00:10:05,330
控制下飞行时

230
00:10:05,500 --> 00:10:08,070
并且评估--然后

231
00:10:08,150 --> 00:10:10,230
计算奖励的总和 对不?

232
00:10:10,340 --> 00:10:11,770
对于你的人类飞行员的表现

233
00:10:11,850 --> 00:10:12,480
并计算

234
00:10:12,550 --> 00:10:16,110
学习控制器的性能回报的总和

235
00:10:16,210 --> 00:10:18,330
比如

236
00:10:18,410 --> 00:10:20,030
看看真实直升机 或问题

237
00:10:20,110 --> 00:10:22,060
或者你可以做真实直升机

238
00:10:22,150 --> 00:10:23,850
或模拟上 你可以做什么

239
00:10:23,960 --> 00:10:26,770
但你可以看到的人类获得

240
00:10:26,850 --> 00:10:29,590
较高或较低的平均奖励的总和

241
00:10:29,660 --> 00:10:32,360
相对于你刚刚学到的控制器 OK?

242
00:10:32,500 --> 00:10:35,940
然后 你这样做 实际上

243
00:10:36,010 --> 00:10:37,540
你可以去飞行直升机

244
00:10:37,680 --> 00:10:39,790
并且权衡奖励的总和 对不?

245
00:10:39,900 --> 00:10:41,920
根据飞机飞过的实际的状态序列

246
00:10:41,990 --> 00:10:43,510
对不?

247
00:10:43,620 --> 00:10:47,640
因此 如果这种情况成立 对不?

248
00:10:47,750 --> 00:10:52,480
如果我的鼠标位置--哦 对不起 OK

249
00:10:52,550 --> 00:10:54,490
如果这种情况也是如此 我的鼠标的位置

250
00:10:54,590 --> 00:10:56,310
如果这个条件成立

251
00:10:56,380 --> 00:10:59,530
π_RL小于π_human

252
00:10:59,630 --> 00:11:01,120
你们在网上上课的同学

253
00:11:01,230 --> 00:11:02,520
我不知道你能否可以看到这个

254
00:11:02,660 --> 00:11:06,000
但这个V π_RL(S_0)

255
00:11:06,100 --> 00:11:08,780
比π_human(S0)更小

256
00:11:08,920 --> 00:11:11,020
但是 如果这个条件成立

257
00:11:11,120 --> 00:11:12,550
那么这表明

258
00:11:12,660 --> 00:11:14,530
强化学习算法是有问题的

259
00:11:14,640 --> 00:11:20,540
因为人类已经发现了一个政策

260
00:11:20,650 --> 00:11:23,140
来比强化学习算法获得更高的报酬

261
00:11:23,240 --> 00:11:24,490
因此 这证明 这表明

262
00:11:24,600 --> 00:11:26,030
你的强化学习算法

263
00:11:26,140 --> 00:11:29,480
的奖励总和没有最大化 对吗?

264
00:11:29,590 --> 00:11:39,120
最后 最后一个条件是这样的--

265
00:11:39,260 --> 00:11:40,740
最后的测试是

266
00:11:40,840 --> 00:11:43,030
如果不等式持有相反的方向--

267
00:11:43,130 --> 00:11:46,170
强化学习算法 因此

268
00:11:46,320 --> 00:11:48,130
如果得到的回报总和

269
00:11:48,240 --> 00:11:50,230
平均比人类更高

270
00:11:50,340 --> 00:11:53,550
但强化学习算法

271
00:11:53,660 --> 00:11:55,850
仍然比人类飞行得更糟糕 对不?

272
00:11:56,000 --> 00:11:57,200
这表明

273
00:11:57,310 --> 00:11:59,480
问题出在COS函数

274
00:11:59,560 --> 00:12:01,350
和奖励函数

275
00:12:01,450 --> 00:12:04,130
是因为强化学习算法

276
00:12:04,210 --> 00:12:06,070
获得的回报总和比人更高

277
00:12:06,210 --> 00:12:07,900
但它仍然飞得比人类差

278
00:12:08,000 --> 00:12:12,150
因此 那表示奖励总和的最大化

279
00:12:12,250 --> 00:12:15,660
和自主飞行不是符合得很好

280
00:12:15,770 --> 00:12:17,180
因此 如果这个成立

281
00:12:17,290 --> 00:12:19,350
那么问题是在你的奖励函数

282
00:12:19,450 --> 00:12:20,680
或者换句话说

283
00:12:20,820 --> 00:12:22,990
问题是在你的优化目标

284
00:12:23,100 --> 00:12:25,370
而不是算法

285
00:12:25,480 --> 00:12:27,440
它试图最大限度地优化目标

286
00:12:27,540 --> 00:12:29,190
所以你可能会改变你的优化目标的算法

287
00:12:29,300 --> 00:12:32,530
换句话说 你可能会改变奖励函数 OK?

288
00:12:32,720 --> 00:12:36,030
当然 这只是一个例子

289
00:12:36,170 --> 00:12:38,740
关于你如何调试强化学习算法的

290
00:12:38,840 --> 00:12:41,960
而这些特别的诊断集合

291
00:12:42,110 --> 00:12:43,890
碰巧仅适用于

292
00:12:44,000 --> 00:12:46,330
因为我们有幸能够

293
00:12:46,430 --> 00:12:49,410
到一个极好的人类飞行员

294
00:12:49,510 --> 00:12:51,580
能来为我们飞行直升机 对不?

295
00:12:51,680 --> 00:12:53,110
如果你没有一个很好的飞行员

296
00:12:53,220 --> 00:12:55,070
那么也许这些诊断将不适用

297
00:12:55,170 --> 00:12:59,100
你要采用其他的

298
00:12:59,170 --> 00:13:00,190
但要再次经过这个

299
00:13:00,260 --> 00:13:01,940
作为诊断源的例子

300
00:13:02,020 --> 00:13:03,820
来调试强化学习算法

301
00:13:03,930 --> 00:13:05,710
这个例子的要点是

302
00:13:05,810 --> 00:13:08,480
没有我想要的这么多

303
00:13:08,550 --> 00:13:10,280
记住诊断的具体情况 对吗?

304
00:13:10,390 --> 00:13:12,930
这一点真的为你自己的问题

305
00:13:13,030 --> 00:13:14,540
监督学习

306
00:13:14,670 --> 00:13:16,650
非监督学习 强化学习

307
00:13:16,750 --> 00:13:17,810
不管哪个算法

308
00:13:17,920 --> 00:13:20,500
你经常拿出你自己的诊断

309
00:13:20,610 --> 00:13:22,320
你自己的调试工具

310
00:13:22,450 --> 00:13:23,440
要搞清楚为什么一个算法是可行的

311
00:13:23,550 --> 00:13:24,840
为什么一个算法是不可行的

312
00:13:24,990 --> 00:13:26,290
这其实是

313
00:13:26,390 --> 00:13:28,460
我们在直升机上做的一个例子

314
00:13:28,560 --> 00:13:29,710
OK?

315
00:13:29,810 --> 00:13:33,280
关于这个有什么问题吗?好的 Justin?

316
00:13:33,380 --> 00:13:35,540
学生:我只是好奇 你怎样收集

317
00:13:35,650 --> 00:13:36,940
比如 训练数据?

318
00:13:37,050 --> 00:13:38,040
像在我们的功课上一样

319
00:13:38,150 --> 00:13:39,390
钟摆下降了很多次

320
00:13:39,500 --> 00:13:41,060
但你是怎么对一个昂贵的直升机进行工作?

321
00:13:41,160 --> 00:13:42,830
教导员(安德鲁吴):是啊

322
00:13:42,930 --> 00:13:44,120
所以 我看看 对

323
00:13:44,270 --> 00:13:45,590
所以在直升机上

324
00:13:45,690 --> 00:13:46,910
我们收集的资料的方式

325
00:13:47,010 --> 00:13:48,700
来了解[听不清]和不可能性

326
00:13:48,800 --> 00:13:53,170
我们通常--不会--做很多的事情

327
00:13:53,280 --> 00:13:54,900
但第一次估计

328
00:13:55,010 --> 00:13:56,790
最基本的合并是

329
00:13:56,890 --> 00:13:58,670
如果你请一个飞行员

330
00:13:58,780 --> 00:14:00,420
为你在周围飞行直升机

331
00:14:00,560 --> 00:14:01,900
并且不要让飞机坠毁

332
00:14:02,040 --> 00:14:03,840
所以 你可以收集大量的数据

333
00:14:03,980 --> 00:14:05,620
是由飞行员控制的

334
00:14:05,720 --> 00:14:07,400
而且 正如我所说 事实证明

335
00:14:07,510 --> 00:14:09,840
在数据收集中

336
00:14:09,980 --> 00:14:12,790
一些标准的方法来收集数据

337
00:14:12,890 --> 00:14:17,080
让你--直升机可以做很多事情

338
00:14:17,220 --> 00:14:18,590
你不想来收集数据

339
00:14:18,700 --> 00:14:22,490
只有表示飞行状态的一小部分

340
00:14:22,630 --> 00:14:25,980
因此 具体的 就是我们常做的是

341
00:14:26,050 --> 00:14:28,340
要求飞行员进行频率扫描

342
00:14:28,480 --> 00:14:31,240
这意味着什么 很非正式的

343
00:14:31,320 --> 00:14:33,360
是你能想象他们拿着操纵杆 对不?

344
00:14:33,500 --> 00:14:34,770
在他们的手中

345
00:14:34,870 --> 00:14:36,320
频率扫描是一个过程

346
00:14:36,390 --> 00:14:38,520
启动非常缓慢振荡

347
00:14:38,630 --> 00:14:42,020
然后启动到你的控制杆

348
00:14:42,170 --> 00:14:44,320
来回移动的速度越来越快

349
00:14:44,460 --> 00:14:46,400
所以你扫理清的范围

350
00:14:46,500 --> 00:14:49,690
频率范围从很慢[听不清]振荡

351
00:14:49,840 --> 00:14:53,000
直到你移动地越来越快

352
00:14:53,110 --> 00:14:54,380
你来回指挥控制杆

353
00:14:54,480 --> 00:14:56,130
因此 这是--哦 好的 谢谢

354
00:14:56,270 --> 00:14:57,930
所以

355
00:14:58,080 --> 00:15:00,890
那是我们在各种机器人上收集数据的一个标

356
00:15:01,080 --> 00:15:02,840
准的方法

357
00:15:02,990 --> 00:15:05,130
它可能会或可能并不适用于不同的机器人

358
00:15:05,240 --> 00:15:06,700
或你的工作在不同的系统

359
00:15:06,800 --> 00:15:09,340
而且 正如我所说

360
00:15:09,440 --> 00:15:11,020
在现实中 我们做了很多事情

361
00:15:11,120 --> 00:15:13,060
有时候 我们有一个控制器

362
00:15:13,170 --> 00:15:14,420
自主收集数据

363
00:15:14,500 --> 00:15:17,390
但还有更复杂的算法 还有别的吗?

364
00:15:17,470 --> 00:15:22,590
学生:在第一点中 目标通信

365
00:15:22,700 --> 00:15:25,760
也许其他的没有映射

366
00:15:25,870 --> 00:15:28,250
模拟器类似的行动

367
00:15:28,390 --> 00:15:29,730
所以在[听不清]这可能是很常见的

368
00:15:29,870 --> 00:15:32,620
你可以[听不清]?

369
00:15:32,760 --> 00:15:34,060
就任何具体的问题

370
00:15:34,170 --> 00:15:38,610
飞行员使用该变量 因此所有[无声]?

371
00:15:38,760 --> 00:15:39,780
教导员(安德鲁吴):是的 对的

372
00:15:39,920 --> 00:15:41,530
所以 你说这点1可能不

373
00:15:41,670 --> 00:15:42,680
准确模拟

374
00:15:42,820 --> 00:15:45,980
它可能是用硬件

375
00:15:46,120 --> 00:15:47,750
做一些奇怪的控制

376
00:15:47,890 --> 00:15:50,070
最终通过一些行动

377
00:15:50,180 --> 00:15:53,970
并转化为一些奇怪的转换

378
00:15:54,120 --> 00:15:56,490
因为它实际上是模拟直升机

379
00:15:56,630 --> 00:15:58,100
我不知道 是啊

380
00:15:58,250 --> 00:15:59,800
我以前清楚地看到这种情况

381
00:15:59,910 --> 00:16:01,300
发生在其他一些机器人上

382
00:16:01,450 --> 00:16:05,230
因此 也许这里的诊断1是一个更好的形式

383
00:16:05,370 --> 00:16:08,090
来决定是否模拟器符合实际的硬件

384
00:16:08,190 --> 00:16:10,690
我不知道 是啊

385
00:16:10,830 --> 00:16:13,110
这是另一个需要注意的地方

386
00:16:13,250 --> 00:16:15,070
如果怀疑这种情况

387
00:16:15,180 --> 00:16:17,790
我现在不能想到一个好的诊断法

388
00:16:17,900 --> 00:16:19,140
来确认它

389
00:16:19,250 --> 00:16:20,550
但再次之前--

390
00:16:20,730 --> 00:16:22,580
这将是一件好事

391
00:16:22,730 --> 00:16:24,800
尝试拿出诊断

392
00:16:24,950 --> 00:16:27,090
来看看是否硬件有可能有错误

393
00:16:27,200 --> 00:16:31,650
我认为这些都是绝不是

394
00:16:31,750 --> 00:16:34,350
确定的诊断法 或类似的东西

395
00:16:34,420 --> 00:16:36,520
这只是一个例子 但将会非常好的

396
00:16:36,600 --> 00:16:38,710
如果你与其他的诊断一起

397
00:16:38,830 --> 00:16:40,040
检查硬件是否工作正常

398
00:16:40,110 --> 00:16:43,830
那将是一件很好的事情

399
00:16:43,940 --> 00:16:45,150
OK 这是--好吧

400
00:16:45,300 --> 00:16:46,730
在我们继续之前的最后几个问题?

401
00:16:46,840 --> 00:16:49,910
学生:你说的奖励函数是?

402
00:16:50,010 --> 00:16:51,400
讲师(安德鲁吴):哦 在这个例子中

403
00:16:51,540 --> 00:16:55,910
我只是使用二次常数

404
00:16:56,020 --> 00:16:57,460
直升机上的

405
00:16:57,570 --> 00:16:59,890
我们经常使用更为复杂的东西

406
00:17:00,000 --> 00:17:02,700
学生:[听不清]你有没有办法知道什么是

407
00:17:02,780 --> 00:17:06,320
所需的重点?

408
00:17:06,460 --> 00:17:09,190
教导员(安德鲁吴):是啊 所以 你可以

409
00:17:09,300 --> 00:17:13,070
计算出--请飞行员在原地盘旋

410
00:17:13,150 --> 00:17:14,250
并且猜他的愿望是什么

411
00:17:14,360 --> 00:17:16,980
同样 这些都不是告诉你的常量 是的

412
00:17:17,090 --> 00:17:21,310
学生:[听不清]

413
00:17:21,400 --> 00:17:23,080
物理是基于学习问题

414
00:17:23,210 --> 00:17:25,090
你--使用物理finian模型

415
00:17:25,260 --> 00:17:30,730
它的实际工作地最好吗?

416
00:17:30,870 --> 00:17:32,320
你懂的 只是

417
00:17:32,430 --> 00:17:33,640
物理告知或者你只是学习[听不清]?

418
00:17:33,720 --> 00:17:34,360
教导员(安德鲁吴):是啊

419
00:17:34,470 --> 00:17:35,780
物理模型运行地很好 对不?

420
00:17:35,920 --> 00:17:37,070
因此 答案是问题到问题之间很多不同

421
00:17:37,180 --> 00:17:39,190
原来 直升机空气动力学

422
00:17:39,290 --> 00:17:41,980
我认为 理解得不够好

423
00:17:42,080 --> 00:17:45,090
你可以看看直升机的"说明书"

424
00:17:45,190 --> 00:17:46,920
并建立一个非常良好的物理模拟器

425
00:17:47,060 --> 00:17:49,090
因此 在直升机上 我们其实是学习的动力

426
00:17:49,240 --> 00:17:51,200
我不知道如何建立一个物理模型

427
00:17:51,320 --> 00:17:54,240
对于其他问题 如果你确实有一个倒立摆的

428
00:17:54,350 --> 00:17:55,460
问题或事情

429
00:17:55,570 --> 00:17:57,600
有许多其他的问题

430
00:17:57,700 --> 00:17:59,610
空气动力学更好的理解

431
00:17:59,750 --> 00:18:02,470
并且物理学的模拟器的工作完全正常

432
00:18:02,580 --> 00:18:03,870
但它取决于很多其他问题--

433
00:18:03,970 --> 00:18:06,380
一些问题的物理学模拟器工作得很好

434
00:18:06,530 --> 00:18:10,840
有些可能工作得不是很好 OK?酷

435
00:18:10,950 --> 00:18:18,960
所以 我想 请收回到黑板上 好的

436
00:18:19,060 --> 00:18:36,760
我还有多少时间? 二十分钟 好了

437
00:18:36,870 --> 00:18:39,040
因此 让我们回来讨论LQR控制

438
00:18:39,150 --> 00:18:40,900
线性二次调节控制

439
00:18:40,980 --> 00:18:43,220
然后我要提前一点告诉你

440
00:18:43,330 --> 00:18:45,110
关于一个LQR的变量

441
00:18:45,220 --> 00:18:47,470
称为微分动态规划

442
00:18:47,550 --> 00:18:48,770
只要回顾一下

443
00:18:48,880 --> 00:18:50,820
只是提醒你LQR--

444
00:18:50,930 --> 00:18:52,260
线性二次调节控制是什么

445
00:18:52,400 --> 00:18:55,780
是在上一讲 我定义了

446
00:18:55,890 --> 00:19:08,220
你的目标是最大边界的问题 对不?

447
00:19:08,370 --> 00:19:12,120
只是找到边界奖励的总和

448
00:19:12,230 --> 00:19:13,800
再也没有贴现了

449
00:19:13,910 --> 00:19:17,710
然后我们提出了这个

450
00:19:17,860 --> 00:20:06,010
动态规划算法 对不?OK

451
00:20:06,110 --> 00:20:07,490
然后 我们在上一讲中提出了这个

452
00:20:07,610 --> 00:20:09,670
动态规划算法

453
00:20:09,790 --> 00:20:11,770
在那里你计算 V*T

454
00:20:11,840 --> 00:20:15,830
那是一个上一个时间步长的值函数

455
00:20:15,940 --> 00:20:16,890
所以 换句话说

456
00:20:17,010 --> 00:20:19,390
价值是什么 如果你在状态S

457
00:20:19,500 --> 00:20:22,580
你只要采取一个动作

458
00:20:22,660 --> 00:20:24,000
然后时钟运行完了

459
00:20:24,120 --> 00:20:25,810
空气动力学编程算法

460
00:20:25,930 --> 00:20:28,720
我们反复计算V*_t

461
00:20:28,910 --> 00:20:31,190
根据V*_t+1这一项

462
00:20:31,330 --> 00:20:36,930
所以我们计算V*_T

463
00:20:37,040 --> 00:20:43,120
然后再次逆运算 对不?

464
00:20:43,220 --> 00:20:48,380
依此类推 直到我们得到V*_0

465
00:20:48,530 --> 00:20:51,740
然后PI*像往常一样

466
00:20:51,890 --> 00:20:55,610
由参数max给定

467
00:20:55,680 --> 00:20:56,880
这是我们在价值函数中定义的

468
00:20:56,980 --> 00:21:02,420
所以上一次 具体的例子

469
00:21:02,520 --> 00:21:06,770
我们看到了--一个具体的例子

470
00:21:06,880 --> 00:21:15,570
这样定义一个边界问题

471
00:21:15,680 --> 00:21:16,560
我们通过DP解决它

472
00:21:16,660 --> 00:21:19,230
是一个我们的直接通过

473
00:21:19,400 --> 00:21:20,590
连续状态和行动计算出的LQR问题

474
00:21:20,730 --> 00:21:35,010
在LQR问题中

475
00:21:35,120 --> 00:21:36,400
我们有这些线性动力学

476
00:21:36,510 --> 00:21:38,810
它的状态ST+1

477
00:21:38,920 --> 00:21:42,570
是以前的状态和行动的线性函数

478
00:21:42,670 --> 00:21:48,100
然后加上这个高斯噪声W_T

479
00:21:48,210 --> 00:21:49,990
这是协方差ΣW.

480
00:21:50,100 --> 00:21:53,740
并且我上一次简要地说过

481
00:21:53,840 --> 00:21:57,400
一个提出这些

482
00:21:57,550 --> 00:21:58,910
线性动力学的特定的方式 对不?

483
00:21:59,090 --> 00:22:00,770
哦 对不起

484
00:22:00,880 --> 00:22:03,690
一个提出

485
00:22:03,800 --> 00:22:07,090
这些线性模型的特定的方式

486
00:22:07,200 --> 00:22:15,420
如果你有一些模拟器 对不?

487
00:22:15,530 --> 00:22:20,510
所以在这个图中

488
00:22:20,650 --> 00:22:24,310
纵轴代表S_t+1

489
00:22:24,430 --> 00:22:26,870
并且横轴代表S_T A_T

490
00:22:26,980 --> 00:22:31,960
所以说 你有一个模拟器 对吗?

491
00:22:32,110 --> 00:22:33,540
比方说 它决定[无声]模拟器

492
00:22:33,690 --> 00:22:35,060
所以我们有一个[无声]模拟器

493
00:22:35,170 --> 00:22:37,440
告诉你下一个状态是S_T+1

494
00:22:37,540 --> 00:22:39,540
是以前的状态和动作的函数

495
00:22:39,650 --> 00:22:42,400
然后你可以选择其中一个点

496
00:22:42,510 --> 00:22:54,130
线性化这个模型

497
00:22:54,240 --> 00:22:57,560
我的意思是 你选择了一个点

498
00:22:57,660 --> 00:22:59,360
估计你的--

499
00:22:59,460 --> 00:23:02,130
使用一个线性函数 估计函数F

500
00:23:02,220 --> 00:23:04,440
此切线 在这一点上的函数F

501
00:23:04,520 --> 00:23:05,700
所以 如果你这样做

502
00:23:05,770 --> 00:23:20,340
你得到S_T+1等于--

503
00:23:20,420 --> 00:23:44,230
对不起 写下了这么多的线

504
00:23:44,380 --> 00:23:47,590
但是这将是

505
00:23:47,730 --> 00:23:51,490
线性估计函数F

506
00:23:51,630 --> 00:23:55,310
我在点S-t A-t周围做了线性化

507
00:23:55,420 --> 00:23:57,590
好的?

508
00:23:57,720 --> 00:24:00,400
所以你可以采取这些

509
00:24:00,500 --> 00:24:11,410
让它缩小到一个线性方程

510
00:24:11,520 --> 00:24:12,990
像下一个状态的S_T+1

511
00:24:13,100 --> 00:24:15,390
现在是一些以前的状态

512
00:24:15,470 --> 00:24:18,240
S_T和A_T的线性函数 这些矩阵 A_T和B_T

513
00:24:18,320 --> 00:24:21,290
将取决于你选择

514
00:24:21,400 --> 00:24:25,090
线性此函数时你所选择的位置 OK?

515
00:24:25,240 --> 00:24:30,190
我上次也说过 这个线性估计

516
00:24:30,340 --> 00:24:32,140
你期望特别好地在

517
00:24:32,250 --> 00:24:34,830
S_T和A_T附近

518
00:24:34,970 --> 00:24:36,690
因为这个线性函数

519
00:24:36,830 --> 00:24:38,510
是F的一个很好的近似 对的?

520
00:24:38,660 --> 00:24:44,360
因此 如果它在这一点邻近 --请说?

521
00:24:44,500 --> 00:24:48,170
学生:[听不清]是有一个假设

522
00:24:48,280 --> 00:24:53,090
你是在寻找第二个邻近的

523
00:24:53,240 --> 00:24:55,310
比如直升机

524
00:24:55,440 --> 00:24:58,170
你假设飞行员的行为是一样的

525
00:24:58,310 --> 00:25:00,670
[听不清]的行为或--

526
00:25:00,820 --> 00:25:01,630
教导员(安德鲁吴):是的 对的

527
00:25:01,730 --> 00:25:05,750
因此 让我不要把这个叫做一个假设

528
00:25:05,890 --> 00:25:07,180
我只想说 当我使用这种算法

529
00:25:07,280 --> 00:25:08,660
当我选择以这种方式线性化

530
00:25:08,760 --> 00:25:10,880
然后我的逼近将会非常好

531
00:25:10,980 --> 00:25:13,860
在这里附近 它在其他地方可能不太好

532
00:25:13,960 --> 00:25:17,820
所以让我--其实当我谈DDP时

533
00:25:17,970 --> 00:25:19,420
我实际使用此属性

534
00:25:19,520 --> 00:25:21,230
这是为什么我现在复习它 OK?

535
00:25:21,380 --> 00:25:22,980
但是 是的 有一种直觉

536
00:25:23,130 --> 00:25:25,920
要在附近进行线性化

537
00:25:26,070 --> 00:25:27,120
靠近附近的状态

538
00:25:27,230 --> 00:25:28,530
所以你希望你的系统要花费大部分时间

539
00:25:28,680 --> 00:25:32,460
对的

540
00:25:32,610 --> 00:25:36,630
所以 好的 因此 这是关于如何建立线性

541
00:25:36,740 --> 00:25:40,340
模型 如果你这样做 那么 哦 你可以--

542
00:25:40,490 --> 00:25:42,720
让我们来看看

543
00:25:42,820 --> 00:25:43,500
所以对于LQR

544
00:25:43,610 --> 00:25:55,460
我们也有这种二次奖励函数 对不?

545
00:25:55,600 --> 00:26:00,110
矩阵U_T和V_T是半正定的

546
00:26:00,210 --> 00:26:02,980
所以回报总是负的 这个是负号

547
00:26:03,100 --> 00:26:06,110
然后如果你使用

548
00:26:06,220 --> 00:26:07,790
动态规划算法

549
00:26:07,900 --> 00:26:11,700
我刚才写下来的 然后--让我们看看

550
00:26:11,850 --> 00:26:16,250
原来 在每一个状态的价值函数

551
00:26:16,400 --> 00:26:17,670
对不起

552
00:26:17,780 --> 00:26:19,640
原来每一个时间步的价值函数

553
00:26:19,740 --> 00:26:23,300
将是一个二次状态函数

554
00:26:23,400 --> 00:26:24,500
可以这样写

555
00:26:24,600 --> 00:26:29,200
所以你初始化

556
00:26:29,330 --> 00:26:30,860
动态规划算法如下

557
00:26:30,970 --> 00:26:43,910
我只写下来

558
00:26:44,060 --> 00:26:46,900
但实际上我只想指出一个属性 但是 好了

559
00:26:46,970 --> 00:26:55,080
这个等式是有点粗糙

560
00:26:55,190 --> 00:26:57,310
但不担心它的大部分细节

561
00:26:57,450 --> 00:27:49,270
让我把这个 擦

562
00:27:49,420 --> 00:27:52,340
我想再写上一个方程(在黑板上) 好的 OK

563
00:27:52,440 --> 00:27:54,180
所以它原来的价值函数是

564
00:27:54,290 --> 00:27:57,890
二次函数 其中V*_T是这个

565
00:27:58,000 --> 00:28:02,960
所以你用这个来初始化动态规划步骤

566
00:28:03,060 --> 00:28:06,480
这个Φ和Ψ给你V大写T

567
00:28:06,580 --> 00:28:08,100
然后它记录了逆

568
00:28:08,200 --> 00:28:10,630
因此 这两个方程表达式--

569
00:28:10,780 --> 00:28:19,570
会给你V_T 作为V_T+1的函数

570
00:28:19,720 --> 00:28:21,900
OK?因此 这种学习算法会导致向后运算

571
00:28:22,000 --> 00:28:25,360
最后一件事情 在同一块黑板上 这一点

572
00:28:25,470 --> 00:28:38,840
所以--对不起 凌乱地使用黑板

573
00:28:38,950 --> 00:28:40,410
我只是想在同一个地方

574
00:28:40,520 --> 00:28:53,380
最后 实际的政策π*(S_T)是

575
00:28:53,490 --> 00:28:55,430
一些S_T的线性函数

576
00:28:55,540 --> 00:28:57,160
所以长期在这里是一个矩阵

577
00:28:57,310 --> 00:28:59,200
其中L_T是是一个矩阵

578
00:28:59,350 --> 00:29:18,500
它等于--很多…乘以… OK?

579
00:29:18,640 --> 00:29:20,790
所以 当你这样做

580
00:29:20,930 --> 00:29:22,850
你现在获得了政策 对不?

581
00:29:22,950 --> 00:29:24,140
那么 具体的是

582
00:29:24,250 --> 00:29:26,160
你运行的动态规划算法

583
00:29:26,300 --> 00:29:29,260
来计算Φ_T和Ψ_T和T的所有值

584
00:29:29,370 --> 00:29:32,520
然后 你插入它来计算矩阵L_T

585
00:29:32,620 --> 00:29:34,970
现在你知道的最佳行动的状态和

586
00:29:35,080 --> 00:29:36,710
[听不清] OK?

587
00:29:36,820 --> 00:29:41,470
因此 有一个非常有趣的属性--

588
00:29:41,620 --> 00:29:43,410
这些方程是一个巨大的烂摊子

589
00:29:43,560 --> 00:29:45,010
但你们自己可以重新推导出它们

590
00:29:45,190 --> 00:29:46,360
但不要担心细节

591
00:29:46,470 --> 00:29:48,460
但是 这是 一个动态规划算法的

592
00:29:48,610 --> 00:29:51,040
一个特定的属性

593
00:29:51,150 --> 00:29:53,090
我想指出 这是很有趣的

594
00:29:53,190 --> 00:29:55,200
如下 请注意

595
00:29:55,310 --> 00:29:58,700
要计算最优的政策

596
00:29:58,840 --> 00:30:01,020
我需要计算这些矩阵L_T

597
00:30:01,170 --> 00:30:06,910
并注意 长L_T依赖于A

598
00:30:07,010 --> 00:30:09,970
它依赖于B 它依赖于 D 它依赖于Φ

599
00:30:10,110 --> 00:30:13,520
但它不依赖于Ψ 对不?

600
00:30:13,660 --> 00:30:18,440
请注意 进一步

601
00:30:18,590 --> 00:30:21,200
当我执行我的动态规划算法时

602
00:30:21,350 --> 00:30:29,980
我对Ψ的递归定义--它取决于--哦

603
00:30:30,120 --> 00:30:41,060
对不起 应该Ψ_T 对的 Ψ_T+1 好了

604
00:30:41,210 --> 00:30:45,110
为了开展我的动态规划算法

605
00:30:45,250 --> 00:30:45,980
对不?

606
00:30:46,120 --> 00:30:48,450
对于Ψ_T 我需要知道Ψ_T+1是什么

607
00:30:48,550 --> 00:30:51,390
所以Ψ_T依赖这些东西

608
00:30:51,530 --> 00:30:54,960
但为了执行动态规划的Φ_T

609
00:30:55,100 --> 00:31:00,210
Φ_T实际上并不依赖于Ψ_T+1 对不?

610
00:31:00,360 --> 00:31:04,500
而 换句话说 为了计算Φ_T

611
00:31:04,640 --> 00:31:06,650
我不需要这些Ψ

612
00:31:06,830 --> 00:31:09,820
如果我要的是Φ

613
00:31:09,920 --> 00:31:13,690
我其实可以省略这一步的

614
00:31:13,800 --> 00:31:14,980
动态规划算法

615
00:31:15,080 --> 00:31:18,100
并没有理会开展

616
00:31:18,200 --> 00:31:20,980
Φ的动态规划算法

617
00:31:21,130 --> 00:31:24,070
做只是我的动态规划算法

618
00:31:24,170 --> 00:31:26,600
为了--对不起 我读错了

619
00:31:26,750 --> 00:31:30,410
你--我可以忘了Ψ

620
00:31:30,510 --> 00:31:32,910
并且只要为Φ矩阵做动态规划更新

621
00:31:33,020 --> 00:31:38,190
然后我为Φ_T做了动态规划更新

622
00:31:38,340 --> 00:31:40,950
然后我可以将其插入这个公式来计算L_T

623
00:31:41,050 --> 00:31:42,230
OK?

624
00:31:42,410 --> 00:31:47,070
你可以做的另外一件事情是

625
00:31:47,170 --> 00:31:49,130
要稍微有效率一点--

626
00:31:49,230 --> 00:31:51,480
效率是不是真正的问题

627
00:31:51,580 --> 00:31:54,190
但如果你想你可以忘记Φ_T

628
00:31:54,290 --> 00:31:56,890
你其实并不需要计算所有

629
00:31:57,010 --> 00:32:01,050
现在 这个有趣的其他属性是

630
00:32:01,150 --> 00:32:09,300
矩阵西格玛W只出现在

631
00:32:09,440 --> 00:32:11,930
我的DP(动态规划)Ψ_T更新中

632
00:32:12,040 --> 00:32:14,920
实际上它并不出现在我的Φ_T的更新中

633
00:32:15,060 --> 00:32:18,990
所以 你还记得--好

634
00:32:19,100 --> 00:32:25,540
我的模型是S_T+1等于A_TS_T加上B_TA_T

635
00:32:25,640 --> 00:32:30,120
加上W_T 这些噪音项 W_T

636
00:32:30,230 --> 00:32:31,990
协方差西格玛W

637
00:32:32,100 --> 00:32:34,450
并且出现的唯一的地方--

638
00:32:34,560 --> 00:32:35,920
噪音方面的协方差

639
00:32:36,030 --> 00:32:37,770
出现在这些Φ_T中

640
00:32:37,880 --> 00:32:38,850
但我只是说

641
00:32:38,950 --> 00:32:40,140
他们可以不使用整个[无声]

642
00:32:40,240 --> 00:32:43,460
Ψ_T的排序算法

643
00:32:43,560 --> 00:32:45,380
那么它的意思是

644
00:32:45,530 --> 00:32:47,640
你可以找到最优的政策

645
00:32:47,780 --> 00:32:50,710
而不用知道噪音项的协方差是什么

646
00:32:50,820 --> 00:32:52,460
OK?

647
00:32:52,570 --> 00:32:58,190
因此 这是一个非常特殊的LQR系统的属性

648
00:32:58,300 --> 00:33:00,000
一旦你改变任何东西

649
00:33:00,100 --> 00:33:02,240
一旦你离开非线性动力学系统

650
00:33:02,340 --> 00:33:04,850
一旦你改变很多方面

651
00:33:04,990 --> 00:33:07,270
因为在谨慎的状态或谨慎的行动中

652
00:33:07,380 --> 00:33:08,510
或其他的

653
00:33:08,620 --> 00:33:10,570
一旦你改变这个问题任何方面

654
00:33:10,720 --> 00:33:12,770
这个属性将不再适用

655
00:33:12,910 --> 00:33:16,910
因为这是在LQR系统中一个非常特殊的属性

656
00:33:17,090 --> 00:33:20,620
最优的政策实际上并不取决于

657
00:33:20,760 --> 00:33:23,250
这些噪音项的噪声幅度 OK?

658
00:33:23,400 --> 00:33:28,080
唯一重要的属性

659
00:33:28,190 --> 00:33:29,730
噪音的零平均

660
00:33:29,910 --> 00:33:36,550
因此 有这种直觉 来计算最优的政策

661
00:33:36,700 --> 00:33:38,030
你可以忽略噪声项

662
00:33:38,180 --> 00:33:40,390
或者那样的话 所以只要你知道你的

663
00:33:40,540 --> 00:33:43,830
状态的S_T+1的预期值--写下来

664
00:33:43,970 --> 00:33:46,760
平均ST+1 是A_TS_T加B_TA_T

665
00:33:46,900 --> 00:33:52,830
再有 如果你可以忽略在你的下一个状态

666
00:33:52,940 --> 00:33:54,170
S_T+1的噪声

667
00:33:54,270 --> 00:33:55,820
和最优的政策不会改变 OK?

668
00:33:55,920 --> 00:33:59,730
所以我们等下再回来

669
00:33:59,810 --> 00:34:02,040
之后 我们将谈论Kalman滤波器

670
00:34:02,140 --> 00:34:04,590
实际上 我们将使用这种LQR系统的属性

671
00:34:04,690 --> 00:34:08,900
只是想指出 注意该值函数不依赖于

672
00:34:08,990 --> 00:34:10,600
噪声的协方差 对的?

673
00:34:10,700 --> 00:34:13,570
这里的价值函数取决于Ψ_T

674
00:34:13,680 --> 00:34:15,510
你的系统中的噪音越大

675
00:34:15,620 --> 00:34:17,060
你的价值函数越糟糕

676
00:34:17,160 --> 00:34:19,100
因此 这取决于噪音

677
00:34:19,180 --> 00:34:20,600
但它的最优政策

678
00:34:20,710 --> 00:34:24,120
不依赖于噪声

679
00:34:24,220 --> 00:34:28,080
我们等下将使用此属性 好了

680
00:34:28,220 --> 00:34:33,150
让我们看看我们如何准时讲完

681
00:34:33,300 --> 00:34:47,060
让我们来看看 对的 好了

682
00:34:47,210 --> 00:34:49,850
因此 让我们现在把它这一边

683
00:34:50,000 --> 00:35:06,560
我现在想要做的是

684
00:35:06,710 --> 00:35:09,280
告诉你应用的LQR的特殊方式

685
00:35:09,430 --> 00:35:11,500
就是所谓的微分动态规划(differential

686
00:35:11,650 --> 00:35:15,020
dynamic programming) 在大多数的例子中

687
00:35:15,120 --> 00:35:17,690
考虑一下尝试控制系统

688
00:35:17,830 --> 00:35:21,920
像直升机或汽车 甚至是一家化工厂

689
00:35:22,060 --> 00:35:24,300
使用连续的状态

690
00:35:24,410 --> 00:35:27,050
因此 为了彻底想清楚这个例子

691
00:35:27,160 --> 00:35:29,780
试想一下 试图控制直升机

692
00:35:29,930 --> 00:35:38,740
比方说 你有一些模拟器

693
00:35:38,810 --> 00:35:40,700
下一个状态是以前的行动的数据的函数

694
00:35:40,780 --> 00:35:42,990
对吗?

695
00:35:43,100 --> 00:35:44,640
比如说

696
00:35:44,740 --> 00:35:47,670
你的模拟器模型是非线性的

697
00:35:47,750 --> 00:35:53,060
但是确定性的(deterministic ) OK?

698
00:35:53,170 --> 00:35:54,160
所以我刚才说

699
00:35:54,270 --> 00:35:56,390
噪音影响不是很大

700
00:35:56,490 --> 00:36:00,300
因此 让我们现在来处理模拟器

701
00:36:00,410 --> 00:36:03,150
但让我们说F是非线性的

702
00:36:03,250 --> 00:36:07,910
比方说 有一些特定的轨迹

703
00:36:08,000 --> 00:36:10,320
你要直升机遵循 好的?

704
00:36:10,460 --> 00:36:12,660
所以我想谈谈如何运用LQR

705
00:36:12,730 --> 00:36:15,750
来获得直升机或汽车或一个化工厂

706
00:36:15,860 --> 00:36:19,310
你的状态变量可能依赖于

707
00:36:19,380 --> 00:36:20,540
不同的化学物质和

708
00:36:20,610 --> 00:36:22,380
你有不同的批次化学品的混合

709
00:36:22,460 --> 00:36:23,810
这真的很容易去思考直升机

710
00:36:23,920 --> 00:36:25,320
比方说

711
00:36:25,420 --> 00:36:27,660
有一些轨迹 你想要直升机遵循

712
00:36:27,780 --> 00:36:29,190
因此

713
00:36:29,300 --> 00:36:32,820
这里是微分动态规划所做的

714
00:36:32,920 --> 00:36:35,000
第一步是

715
00:36:35,070 --> 00:36:42,780
我要去调用一些标称轨迹

716
00:36:42,920 --> 00:36:47,140
对不?

717
00:36:47,280 --> 00:36:59,550
所以我们把它叫做S_0 A_0 OK?

718
00:36:59,700 --> 00:37:02,670
因此 一种方式是将

719
00:37:02,820 --> 00:37:04,730
如果你有一些非常糟糕的控制器--

720
00:37:04,870 --> 00:37:07,580
恼人的飞行直升机的控制器

721
00:37:07,690 --> 00:37:09,630
不是一个很好的控制器

722
00:37:09,730 --> 00:37:13,170
但是 你可能使用一个

723
00:37:13,280 --> 00:37:15,180
非常坏的 一个很草率的 控制器

724
00:37:15,280 --> 00:37:17,140
继续飞行直升机 你会得到一些

725
00:37:17,250 --> 00:37:19,160
状态和动作的序列 对吗?

726
00:37:19,230 --> 00:37:21,310
所以 我要去--

727
00:37:21,380 --> 00:37:23,070
我只需要调用这个序列状态和动作的轨迹

728
00:37:23,170 --> 00:37:25,460
--标称轨迹

729
00:37:25,560 --> 00:37:38,820
然后 我将围绕这个标称轨迹 来线性化F

730
00:37:38,930 --> 00:37:50,650
OK?所以 即 对不对?

731
00:37:50,750 --> 00:37:52,310
我将使用相同的事情

732
00:37:52,420 --> 00:37:57,440
所以通常乘以F T 来估计S_T+1

733
00:37:57,540 --> 00:38:01,170
作为我们刚看到的线性化的东西

734
00:38:01,270 --> 00:38:22,090
乘以--加上其他的项 OK?

735
00:38:22,240 --> 00:38:32,640
然后你下来 总结提取ATST加BTST

736
00:38:32,790 --> 00:38:33,780
OK?

737
00:38:33,930 --> 00:38:35,580
因此 这实际上是第一次

738
00:38:35,720 --> 00:38:40,140
我会做出明确的使用LQR能力

739
00:38:40,240 --> 00:38:41,390
或这些更精细的边界问题

740
00:38:41,510 --> 00:38:43,900
来处理非稳定动态

741
00:38:44,040 --> 00:38:46,370
特别是 在这个例子中

742
00:38:46,470 --> 00:38:51,180
将重要的是 AT和BT依赖于时间

743
00:38:51,320 --> 00:38:55,900
--哦 对不起 OK?

744
00:38:56,050 --> 00:38:58,830
所以 直觉是

745
00:38:58,970 --> 00:39:01,440
即使这是一个非常草率的控制器

746
00:39:01,580 --> 00:39:03,190
或者即使你有一个非常糟糕的控制器

747
00:39:03,340 --> 00:39:06,130
拿出你原有的标称轨迹

748
00:39:06,280 --> 00:39:10,220
你仍然期望也许 对不?

749
00:39:10,360 --> 00:39:13,120
你期望你的状态和行动在时间T

750
00:39:13,230 --> 00:39:21,080
可能合理地相似于

751
00:39:21,220 --> 00:39:23,480
甚至粗糙控制器所做的 对不?

752
00:39:23,590 --> 00:39:24,620
所以 你要一个飞行轨迹

753
00:39:24,760 --> 00:39:26,590
也许你想使一个90度的大转弯

754
00:39:26,740 --> 00:39:28,080
也许 如果一个糟糕的控制器

755
00:39:28,190 --> 00:39:29,490
做了一件非常马虎的工作

756
00:39:29,600 --> 00:39:31,310
但在任何给定时间

757
00:39:31,410 --> 00:39:33,200
你还在这个轨迹中运行

758
00:39:33,300 --> 00:39:37,140
因此 这是真的告诉你 说

759
00:39:37,280 --> 00:39:40,060
沿着90度转向的轨迹 只是非常粗略的

760
00:39:40,170 --> 00:39:41,180
沿轨迹

761
00:39:41,330 --> 00:39:43,130
你希望在任何特定时间

762
00:39:43,260 --> 00:39:48,410
所以让我们围绕该点进行线性化 OK?

763
00:39:48,520 --> 00:40:07,160
然后 你会 - 发现线性模型

764
00:40:07,300 --> 00:40:08,920
你运行的LQR得到这个

765
00:40:09,070 --> 00:40:12,080
特定的线性模型的最优政策

766
00:40:12,260 --> 00:40:16,150
现在你有一个更好的政策

767
00:40:16,290 --> 00:40:21,580
你做的最后一点是--孩子们

768
00:40:21,690 --> 00:40:46,950
我会写在不同的黑板上 我猜 好了 擦

769
00:40:47,060 --> 00:40:54,610
最后一步是 你使用模拟器 一个模型

770
00:40:54,760 --> 00:40:57,750
来提出一个新的正常轨迹

771
00:40:57,890 --> 00:41:32,960
所以 即 OK?

772
00:41:33,110 --> 00:41:35,170
所以 现在你使用刚刚学到的控制器

773
00:41:35,280 --> 00:41:38,150
基本上尝试在你的模拟器中飞行直升机

774
00:41:38,300 --> 00:41:41,070
所以 你把模拟器初始化到初始状态

775
00:41:41,170 --> 00:41:42,730
我把它叫做S-0

776
00:41:42,840 --> 00:41:44,410
你会运行每一个时间步

777
00:41:44,560 --> 00:41:46,990
你可以选择一个动作 我把它叫做A-T

778
00:41:47,090 --> 00:41:50,340
使用控制器πT 你刚刚学的使用LQR

779
00:41:50,440 --> 00:41:53,200
然后你可以模拟在时间上 对不?

780
00:41:53,300 --> 00:41:54,840
你可以使用模拟器 函数F

781
00:41:54,950 --> 00:41:59,810
告诉你下一个状态S-T+1将是

782
00:41:59,910 --> 00:42:01,320
你以前的状态和行动A-T A-T的函数

783
00:42:01,430 --> 00:42:10,260
然后你围绕这一新的轨迹进行线性化

784
00:42:10,410 --> 00:42:18,480
并且重复 OK?

785
00:42:18,590 --> 00:42:21,950
所以 现在你有一个新的正常轨迹

786
00:42:22,090 --> 00:42:25,380
你围绕这个新的轨迹线性化你的模拟器

787
00:42:25,480 --> 00:42:27,810
然后重复整个过程

788
00:42:27,920 --> 00:42:29,780
我想回到算法的第二个步骤

789
00:42:29,930 --> 00:42:33,810
而这原来是一个令人惊讶的有效的程序

790
00:42:33,970 --> 00:42:43,570
因此 这种算法可以做什么的图如下

791
00:42:43,670 --> 00:42:44,970
比方说 你知道

792
00:42:45,080 --> 00:42:47,560
你想直升机上的一个90度的大转弯

793
00:42:47,640 --> 00:42:50,080
让我们看到

794
00:42:50,190 --> 00:42:52,140
一个直升机遵循这样的轨迹

795
00:42:52,290 --> 00:42:55,370
跟随一个非常坏的控制器

796
00:42:55,480 --> 00:42:56,570
我只是 你知道

797
00:42:56,690 --> 00:42:57,870
设计(简单)的一些控制器 不论什么

798
00:42:57,980 --> 00:42:59,540
有办法提出一个

799
00:42:59,640 --> 00:43:01,290
初步的正常轨迹

800
00:43:01,430 --> 00:43:07,940
也许你的初始控制器转过了头

801
00:43:08,080 --> 00:43:09,710
转宽了 对不?

802
00:43:09,820 --> 00:43:11,910
但现在你可以使用

803
00:43:12,010 --> 00:43:13,950
这些点来线性化模拟器

804
00:43:14,050 --> 00:43:16,360
因此 线性化一个非线性模拟器

805
00:43:16,540 --> 00:43:18,060
这个想法是

806
00:43:18,160 --> 00:43:20,450
也许这种状态不是这样一个很糟糕的近似

807
00:43:20,550 --> 00:43:23,190
也许在这种状态序列的线性逼近

808
00:43:23,290 --> 00:43:26,990
实际上是合理的

809
00:43:27,100 --> 00:43:30,450
因为你的直升机将不完全在该状态下

810
00:43:30,560 --> 00:43:32,760
但在每一个时间步接近该状态序列

811
00:43:32,860 --> 00:43:35,960
在一个DDP过程之后

812
00:43:36,070 --> 00:43:41,760
那就是目标轨迹 也许你一点点接近

813
00:43:41,860 --> 00:43:46,470
而现在你有一个更好的地方周围

814
00:43:46,570 --> 00:43:47,720
进行线性化

815
00:43:47,830 --> 00:43:49,620
然后另一个DDP线性化之后

816
00:43:49,770 --> 00:43:56,930
越来越靠近该轨迹

817
00:43:57,040 --> 00:43:59,770
并且找到你想要的轨迹 OK?

818
00:43:59,950 --> 00:44:04,720
因此 原来 DDP是一个--

819
00:44:04,870 --> 00:44:07,820
它原来是一个局部搜索算法的一种形式

820
00:44:07,940 --> 00:44:09,890
在每次迭代中

821
00:44:10,000 --> 00:44:12,460
你找到一个稍微好一点的地方以进行线化

822
00:44:12,530 --> 00:44:14,650
所以你需要一个稍微更好地控制 并且重复

823
00:44:14,800 --> 00:44:16,680
而且我们确实做到这一点 – 这

824
00:44:16,800 --> 00:44:18,720
实际上是我们在直升机上所做的事情之一

825
00:44:18,870 --> 00:44:21,110
而这个作品非常好

826
00:44:21,220 --> 00:44:23,110
在许多 - 这出奇地好--在很多问题中

827
00:44:23,230 --> 00:44:28,150
这工作得很好 酷

828
00:44:28,220 --> 00:44:29,830
我认为 - 我其实是要展示一些

829
00:44:29,910 --> 00:44:31,220
直升机的视频

830
00:44:31,290 --> 00:44:32,380
但由于时间关系

831
00:44:32,480 --> 00:44:33,720
让我只能推迟到下一讲

832
00:44:33,870 --> 00:44:35,380
我将会在下一讲中

833
00:44:35,520 --> 00:44:36,710
告诉你一堆很酷的关于直升机事情

834
00:44:36,850 --> 00:44:37,970
但让我们继续之前

835
00:44:38,080 --> 00:44:44,940
检查是否有关于这个的问题 请说?

836
00:44:45,050 --> 00:44:48,810
学生:[听不清]

837
00:44:48,920 --> 00:44:50,590
教导员(安德鲁吴):在此例子中吗?

838
00:44:50,690 --> 00:44:53,430
是的 是的 正确的 是的 所以 我要去 –

839
00:44:53,570 --> 00:44:55,090
让我们挑选一些边界T

840
00:44:55,230 --> 00:44:57,520
所以我要让我的模拟器的跑遍整个轨迹

841
00:44:57,630 --> 00:45:08,080
所以我最终用一个新的标称轨迹

842
00:45:08,180 --> 00:45:11,960
来进行线性化 对吗?OK?

843
00:45:12,060 --> 00:45:15,140
请说?

844
00:45:15,240 --> 00:45:17,840
学生:那么这种方法给你

845
00:45:17,940 --> 00:45:21,690
比如 高斯执行 某种行动吗?

846
00:45:21,790 --> 00:45:24,080
就像你谈到一样

847
00:45:24,190 --> 00:45:25,500
90度的大转弯的事情或东西

848
00:45:25,640 --> 00:45:27,050
教导员(安德鲁吴):对

849
00:45:27,160 --> 00:45:29,040
学生:所以这是从一个像

850
00:45:29,140 --> 00:45:32,680
这是从一个 一个90度的大转弯 或你可以

851
00:45:32,780 --> 00:45:33,790
【听不见】?

852
00:45:33,860 --> 00:45:35,180
教导员(安德鲁吴):是啊

853
00:45:35,280 --> 00:45:37,500
因此 事实证明 - 所以明确地这是用来 –

854
00:45:37,640 --> 00:45:39,400
让我们来看看

855
00:45:39,500 --> 00:45:40,860
你去想一想

856
00:45:40,960 --> 00:45:43,420
如果有要遵循一个特定的轨迹

857
00:45:43,520 --> 00:45:44,900
我刚要去

858
00:45:45,000 --> 00:45:46,910
汽车或直升机或者它可能是在一个化工厂

859
00:45:46,980 --> 00:45:48,120
对吗?

860
00:45:48,260 --> 00:45:50,330
如果你期望的经过系统时间的推移

861
00:45:50,440 --> 00:45:52,450
有一些特定的状态序列

862
00:45:52,590 --> 00:45:57,230
让你真正想要在不同的时间进行线性化 –

863
00:45:57,330 --> 00:45:59,910
对不起 因此 不同时间

864
00:46:00,020 --> 00:46:02,820
你想要不同的线性估计 你的动态 对吗?

865
00:46:02,920 --> 00:46:10,710
所以 我真正开始嘲笑这个固定模拟器

866
00:46:10,820 --> 00:46:12,120
对不?我的意思是 这个函数F

867
00:46:12,220 --> 00:46:14,400
所有的时间步长中 它可能是相同的函数F

868
00:46:14,500 --> 00:46:16,170
但DDP的要点是

869
00:46:16,280 --> 00:46:18,570
在不同的时间步中

870
00:46:18,720 --> 00:46:20,180
我可能要使用不同的线性化

871
00:46:20,250 --> 00:46:22,930
因此 很多算法的内循环

872
00:46:23,040 --> 00:46:25,230
导致越来越好的

873
00:46:25,330 --> 00:46:27,940
地方来进行线性化

874
00:46:28,080 --> 00:46:30,420
在不同的时间

875
00:46:30,530 --> 00:46:32,470
我将在不同地方进行线性化 明白吗?

876
00:46:32,580 --> 00:46:36,850
酷 好吧 酷 所以这就是DDP

877
00:46:36,960 --> 00:46:40,460
我将在下一讲展示DDP的结果的例子

878
00:46:40,560 --> 00:46:50,040
所以我想做的最后一件事情

879
00:46:50,180 --> 00:47:02,040
是谈Kalman滤波和LQG控制

880
00:47:02,120 --> 00:47:03,680
线性二次高斯控制

881
00:47:03,780 --> 00:47:06,730
我想要做的是

882
00:47:06,840 --> 00:47:09,680
实际上谈论不同MDP问题的类型

883
00:47:09,780 --> 00:47:13,120
我们没有明确地观察到那个状态 对不?

884
00:47:13,190 --> 00:47:15,540
到目前为止 在我一直谈论的每一个中

885
00:47:15,610 --> 00:47:17,920
我一直在假设

886
00:47:17,990 --> 00:47:19,910
你知道系统的状态是什么

887
00:47:20,020 --> 00:47:22,280
所以你可以计算出

888
00:47:22,350 --> 00:47:25,190
一个关于函数的政策 关于它的状态是什么

889
00:47:25,300 --> 00:47:26,400
如果你一切准备就绪了

890
00:47:26,510 --> 00:47:29,990
你懂的 我们所采取的行动是L_T*S_T

891
00:47:30,060 --> 00:47:30,950
对不?

892
00:47:31,090 --> 00:47:31,910
因此 要计算的动作

893
00:47:32,050 --> 00:47:33,230
你需要知道状态是什么

894
00:47:33,330 --> 00:47:35,650
我现在想要做的是

895
00:47:35,760 --> 00:47:37,180
谈论问题的不同类型

896
00:47:37,280 --> 00:47:40,120
你没有明确地观察状态

897
00:47:40,240 --> 00:47:43,290
事实上 -我们甚至谈论的控制之前

898
00:47:43,390 --> 00:47:44,940
让我谈论不同的问题--

899
00:47:45,010 --> 00:47:47,830
现在先不用管控制

900
00:47:47,940 --> 00:47:49,680
只是谈论一些动力系统

901
00:47:49,790 --> 00:47:51,930
你可能没有明确地观察状态

902
00:47:52,040 --> 00:47:54,530
然后我们回来控制某些系统

903
00:47:54,650 --> 00:47:57,500
OK?

904
00:47:57,620 --> 00:48:01,210
作为一个具体的例子 比方说

905
00:48:01,320 --> 00:48:02,650
只是一个例子 思考

906
00:48:02,790 --> 00:48:06,110
想象使用雷达跟踪直升机 对不?

907
00:48:06,220 --> 00:48:09,800
因此 我们可能模型化直升机

908
00:48:09,910 --> 00:48:13,660
这将是惊人的简化直升机模型

909
00:48:13,770 --> 00:48:16,480
因为 你知道 一些非线性动力学系统

910
00:48:16,600 --> 00:48:19,480
因此 下一个状态S_T +1等于 AS_T 加上W_T

911
00:48:19,630 --> 00:48:21,790
我们现在先不用管控制 好吗?

912
00:48:21,900 --> 00:48:23,700
我们等下将填补控制

913
00:48:23,810 --> 00:48:26,300
而就在这个例子中

914
00:48:26,450 --> 00:48:35,640
我会用一个非常简化的状态 对不?

915
00:48:35,750 --> 00:48:36,970
我的状态仅仅是

916
00:48:37,080 --> 00:48:39,520
一个在X和Y方向速度的位置

917
00:48:39,670 --> 00:48:47,270
所以你可以选择这个作为一个矩阵 - OK?

918
00:48:47,420 --> 00:49:03,130
作为一个非常简单的 - 作为一个

919
00:49:03,220 --> 00:49:04,130
极度简化的模型

920
00:49:04,240 --> 00:49:06,290
比如 一架飞机或物体在2--D空间中移动

921
00:49:07,430 --> 00:49:07,530
飞机或移动物体的动态可能是这个样子

922
00:49:09,020 --> 00:49:11,190
所以 试想你有模拟器

923
00:49:11,310 --> 00:49:12,050
并且你有一个雷达

924
00:49:12,160 --> 00:49:14,080
你跟踪雷达上你的光点

925
00:49:14,190 --> 00:49:15,980
你要估计就像XY位置和它的XY速度的位置

926
00:49:16,120 --> 00:49:19,070
或直升机的状态

927
00:49:19,180 --> 00:49:22,530
并且你有一个很简单的动力学模型

928
00:49:22,640 --> 00:49:23,970
直升机可能做什么

929
00:49:24,100 --> 00:49:27,570
所以这个矩阵 这只是说

930
00:49:27,670 --> 00:49:34,640
XT+1等于XT+X*T加噪音

931
00:49:34,740 --> 00:49:40,240
这第一个等式

932
00:49:40,350 --> 00:49:43,910
第二个方程表示的X*T+1

933
00:49:44,020 --> 00:49:46,630
等于0.9乘以X*T+9

934
00:49:46,740 --> 00:49:51,670
是的 这是一个令人惊讶的简化模型

935
00:49:51,780 --> 00:49:55,000
一个飞行器可能是这个样子

936
00:49:55,150 --> 00:50:00,330
这里是更有趣的部分

937
00:50:00,430 --> 00:50:01,520
那是 –

938
00:50:01,620 --> 00:50:04,950
如果你用一些传感器跟踪直升机

939
00:50:05,060 --> 00:50:08,530
你不会明确地观察到全状态

940
00:50:08,640 --> 00:50:10,170
但这张图的例子

941
00:50:10,270 --> 00:50:13,910
让我们说 我们可以观察YT

942
00:50:14,060 --> 00:50:26,650
这是CST加上VT VT是一个随机变量 –

943
00:50:26,760 --> 00:50:28,030
高斯随机变量 说

944
00:50:28,140 --> 00:50:30,030
零均值与协方差的高斯噪声

945
00:50:30,130 --> 00:50:31,830
由Sigma V给定 OK?

946
00:50:31,980 --> 00:50:45,930
因此 在这个例子中 让我们说 C是那个--

947
00:50:46,040 --> 00:50:53,940
所以CST是等于XY 对不?

948
00:50:54,050 --> 00:50:57,080
使用这个状态向量 并且乘用Z 你得到了XY

949
00:50:57,190 --> 00:50:58,710
让我们看看传感器是什么

950
00:50:58,860 --> 00:51:00,330
也许是一个雷达 可能是一个视觉系统

951
00:51:00,440 --> 00:51:03,190
我不知道的东西

952
00:51:03,300 --> 00:51:07,090
只要观察跟踪你的直升机位置

953
00:51:07,250 --> 00:51:15,240
因此 这张图

954
00:51:15,380 --> 00:51:29,750
因此直升机经过一些状态的顺序

955
00:51:29,870 --> 00:51:33,170
比方说 它通过一些平滑的轨迹

956
00:51:33,280 --> 00:51:42,570
不管怎样

957
00:51:42,680 --> 00:51:44,790
它做一个缓慢的转动

958
00:51:44,910 --> 00:51:47,260
所以真正的状态是四维的

959
00:51:47,340 --> 00:51:48,990
但我只是绘制两个维度 对吗?

960
00:51:49,100 --> 00:51:52,930
所以也许在这里你有一个摄像头传感器

961
00:51:53,040 --> 00:51:57,950
或一个雷达什么的 这张图的例子

962
00:51:58,070 --> 00:52:00,040
比方说 在你观察到的噪音是

963
00:52:00,160 --> 00:52:02,820
在垂直轴大于水平轴

964
00:52:02,930 --> 00:52:04,900
所以你得到的实际上是

965
00:52:04,980 --> 00:52:09,760
一个五个高斯序列样本

966
00:52:09,830 --> 00:52:13,240
所以 你可能在时间步长1中

967
00:52:13,390 --> 00:52:14,730
会观察到有直升机在这里 时间第二步

968
00:52:14,880 --> 00:52:18,760
观察它在这里 观察在时间3 时间4 时间5

969
00:52:18,870 --> 00:52:20,180
OK?

970
00:52:20,290 --> 00:52:22,180
好的 所以这是你的--

971
00:52:22,280 --> 00:52:23,940
这里有一序列位置

972
00:52:24,060 --> 00:52:25,390
你的相机估计而提供给你的

973
00:52:25,470 --> 00:52:31,410
并给予各种各样的观察值

974
00:52:31,550 --> 00:52:35,070
你能不能估计系统的实际状态?OK?

975
00:52:35,220 --> 00:52:39,270
因此 这些橙色的东西 我想 对不?OK?

976
00:52:39,420 --> 00:52:49,380
这些橙色的东西是你的观察结果YT

977
00:52:49,480 --> 00:52:53,700
并且每次测试直升机的状态

978
00:52:53,840 --> 00:52:56,710
对于它 所以每个时间直升机的位置

979
00:52:56,820 --> 00:52:58,820
显然 你不想只是依靠橙色的十字架

980
00:52:58,910 --> 00:52:59,920
因为太嘈杂(偏差)

981
00:52:59,980 --> 00:53:03,030
他们也没有给你的速度 对不?

982
00:53:03,130 --> 00:53:05,020
所以你只观察状态变量的一个子集

983
00:53:05,120 --> 00:53:09,660
所以 你可以做什么?因此 具体的 - 好

984
00:53:09,770 --> 00:53:12,710
你实际不能得到观察的真实位置

985
00:53:12,820 --> 00:53:13,610
对不?

986
00:53:13,710 --> 00:53:16,710
所有你要做的是 观察那些橙色的十字架

987
00:53:16,810 --> 00:53:20,180
我想如果我能 我要擦除椭圆形 好的

988
00:53:20,290 --> 00:53:26,670
你的想法 问题是 - 是啊

989
00:53:26,770 --> 00:53:28,910
你知道我想要做什么

990
00:53:29,010 --> 00:53:33,280
鉴于橙色的十字架

991
00:53:33,390 --> 00:53:36,410
你能得到系统状态的一个很好的估计

992
00:53:36,520 --> 00:53:38,130
在每一个时间步长?

993
00:53:38,230 --> 00:53:40,600
因此 事实证明 –

994
00:53:40,740 --> 00:53:45,540
所以你想要做的是估计状态的分布

995
00:53:45,640 --> 00:53:54,050
给定所有以前的观测结果 对吗?

996
00:53:54,150 --> 00:53:55,960
所以给定的观测结果 要知道

997
00:53:56,070 --> 00:53:57,460
一 二 三 四 五

998
00:53:57,610 --> 00:53:59,230
目前直升机在哪里?

999
00:53:59,340 --> 00:54:04,450
因此 原来 那个随机变量

1000
00:54:04,560 --> 00:54:09,200
S0 S1 到ST 并且Y1到ST

1001
00:54:09,310 --> 00:54:11,100
有一个共同的高斯分布 对不对?

1002
00:54:11,200 --> 00:54:24,630
因此 你可以做的事情之一是

1003
00:54:24,750 --> 00:54:27,150
构建一个联合高斯分布 –

1004
00:54:27,260 --> 00:54:31,850
可以定义矢量值随机变量Z S0 S1

1005
00:54:31,960 --> 00:54:36,280
上升到ST Y1可达YT 对不?

1006
00:54:36,390 --> 00:54:38,200
因此 事实证明

1007
00:54:38,350 --> 00:54:45,960
Z将有一些一些的均值和一些协方差矩阵的

1008
00:54:46,070 --> 00:54:47,580
高斯分布

1009
00:54:47,690 --> 00:54:51,860
使用高斯边缘化

1010
00:54:51,970 --> 00:54:54,310
和调节公式

1011
00:54:54,490 --> 00:54:55,700
但我觉得之前的一种方式

1012
00:54:55,810 --> 00:54:58,400
当我们谈到这个类的因素分析

1013
00:54:58,510 --> 00:55:00,230
我们谈到有关如何计算高斯模型的边缘分布

1014
00:55:00,330 --> 00:55:02,470
和条件分布

1015
00:55:02,590 --> 00:55:03,930
但是 使用这些公式

1016
00:55:04,040 --> 00:55:05,420
你可以计算这个东西

1017
00:55:05,520 --> 00:55:10,680
你可以计算 对不对?

1018
00:55:10,790 --> 00:55:12,530
你可以计算 有条件的分布

1019
00:55:12,630 --> 00:55:16,030
这将提供一个很好的估计当前状态ST OK?

1020
00:55:16,100 --> 00:55:19,190
但显然这是一种

1021
00:55:19,300 --> 00:55:22,000
计算非常低效的方式

1022
00:55:22,110 --> 00:55:29,030
因为这些手段和协方差矩阵将

1023
00:55:29,170 --> 00:55:30,670
随着时间步长而变成线性的

1024
00:55:30,780 --> 00:55:33,330
数以万计的时间步长来跟踪你的直升机

1025
00:55:33,400 --> 00:55:36,100
他们是巨大的协方差矩阵

1026
00:55:36,210 --> 00:55:37,620
所以 这是一个概念上正确的方法

1027
00:55:37,780 --> 00:55:38,930
而执行此计算

1028
00:55:39,120 --> 00:55:40,950
是不太合理的方式

1029
00:55:41,100 --> 00:55:46,350
相反

1030
00:55:46,500 --> 00:55:54,560
所以称为Kalman滤波算法

1031
00:55:54,670 --> 00:55:56,190
它允许你组织你的计算

1032
00:55:56,340 --> 00:55:58,910
有效地做到这一点

1033
00:55:59,010 --> 00:56:02,030
另外 如果你还记得

1034
00:56:02,170 --> 00:56:06,600
Dan关于HMM的Kalman滤波模型的讨论

1035
00:56:06,710 --> 00:56:08,860
实际上是一个隐式马尔可夫(Markov)模型

1036
00:56:08,970 --> 00:56:11,730
这些Kalman的是只对那些你

1037
00:56:11,840 --> 00:56:13,200
出席过Dan的讨论

1038
00:56:13,310 --> 00:56:16,460
如果我将要说的 不太明白

1039
00:56:16,570 --> 00:56:17,950
但是 如果你还记得

1040
00:56:18,060 --> 00:56:19,820
Dan的隐式马尔可夫模型的讨论

1041
00:56:19,930 --> 00:56:23,260
它其实是Kalman滤波模型

1042
00:56:23,370 --> 00:56:24,810
这个非线性动力学系统与观测结果

1043
00:56:24,910 --> 00:56:28,610
实际上是一个HMM的问题  -

1044
00:56:28,760 --> 00:56:38,430
让我们来看看 不幸的是 符号的有点不同

1045
00:56:38,540 --> 00:56:41,890
因为Dan借鉴了多个研究社群

1046
00:56:42,000 --> 00:56:45,190
使用这些相同的想法有冲突

1047
00:56:45,300 --> 00:56:47,980
因此 Dan使用的符号 我认为

1048
00:56:48,090 --> 00:56:51,750
在不同的社群中形成的

1049
00:56:51,860 --> 00:56:54,010
与强化学习的社会符号有冲突

1050
00:56:54,120 --> 00:57:00,730
因此 在Dan 在HMM章节的符号

1051
00:57:00,840 --> 00:57:01,950
Z和X是用来表示

1052
00:57:02,060 --> 00:57:03,340
状态和观测结果

1053
00:57:03,460 --> 00:57:05,180
今天 我用S和X

1054
00:57:05,290 --> 00:57:07,130
表示状态和观测结果 Ok?

1055
00:57:07,240 --> 00:57:11,180
但事实证明 我将要做的是

1056
00:57:11,290 --> 00:57:15,490
原来是一个连续的状态隐式马尔可夫模型

1057
00:57:15,600 --> 00:57:17,020
而不是离散的状态

1058
00:57:17,160 --> 00:57:19,290
这是判断的章节 好了

1059
00:57:19,440 --> 00:57:21,440
如果你确实没有出席那个讨论部分

1060
00:57:21,590 --> 00:57:24,170
然后忘记一切 我在最后一分钟只是说

1061
00:57:24,270 --> 00:57:31,350
因此 这里的卡尔曼滤波的轮廓

1062
00:57:31,460 --> 00:57:38,380
事实证明 所以这是一个草书算法

1063
00:57:38,480 --> 00:57:41,130
所以事实证明 如果我有计算的P(S_T)

1064
00:57:41,240 --> 00:57:43,020
给予Y1到Y_T

1065
00:57:43,160 --> 00:57:49,470
卡尔曼滤波组织这些计算为步骤

1066
00:57:49,620 --> 00:57:52,640
第一步是所谓的预测步骤

1067
00:57:52,760 --> 00:57:56,390
给定P(ST) -

1068
00:57:56,510 --> 00:58:00,390
给定了Y_1到Y_T 你已经得到了P(S_T)

1069
00:58:00,500 --> 00:58:04,550
给定Y1到YT 你计算P(S_T+1)

1070
00:58:04,660 --> 00:58:18,100
然后其他步骤是所谓的更新步骤

1071
00:58:18,220 --> 00:58:20,530
给定这个第二行 你计算这三行

1072
00:58:20,670 --> 00:58:23,320
OK?采取时间T的观测结果

1073
00:58:23,420 --> 00:58:26,120
你要合并很多时间

1074
00:58:26,190 --> 00:58:29,190
T+1的观测结果

1075
00:58:29,270 --> 00:58:33,930
因此 具体的 - 哦 让我们来看看

1076
00:58:34,010 --> 00:58:47,560
在预测步骤 事实证明 –

1077
00:58:47,630 --> 00:58:53,580
所以我要做的是

1078
00:58:53,700 --> 00:58:56,960
实际上只是概述的卡尔曼滤波的主要步骤

1079
00:58:57,040 --> 00:59:00,060
实际上 我不会推导出这个算法

1080
00:59:00,140 --> 00:59:01,560
并证明它是正确的

1081
00:59:01,710 --> 00:59:04,330
事实证明 我不知道

1082
00:59:04,410 --> 00:59:06,810
推导出这个证明

1083
00:59:06,920 --> 00:59:09,500
可能是意味深长的 - 它可能 我不知道

1084
00:59:09,610 --> 00:59:11,520
很难 或者稍微

1085
00:59:11,630 --> 00:59:13,680
比你们所做的功课稍微容易一点

1086
00:59:13,830 --> 00:59:16,030
所以你做了一些非常难的功课

1087
00:59:16,170 --> 00:59:17,940
这样你们就可以自己证明推导

1088
00:59:18,050 --> 00:59:19,470
这只是写出来主要轮廓

1089
00:59:19,590 --> 00:59:23,160
和算法的结论

1090
00:59:23,260 --> 00:59:27,440
因此 给定的Y1到YT

1091
00:59:27,550 --> 00:59:34,390
对于ST的结果

1092
00:59:34,460 --> 00:59:55,390
如果是这样 然后 - OK?

1093
00:59:55,500 --> 01:00:24,430
因此 给定的ST

1094
01:00:24,540 --> 01:00:28,450
给予Y1到YT 计算ST的分布

1095
01:00:28,560 --> 01:00:31,380
并且给定Y1到YT的高斯

1096
01:00:31,490 --> 01:00:32,780
计算ST+1的分布

1097
01:00:32,900 --> 01:00:34,440
通过这个均值和协方差

1098
01:00:34,580 --> 01:00:35,630
你用这两个公式计算的

1099
01:00:35,750 --> 01:00:37,140
均值和协方差协方差

1100
01:00:37,250 --> 01:00:39,650
只是作为一个符号的点 对不对?

1101
01:00:39,760 --> 01:00:43,240
我使用的ST和YT

1102
01:00:43,340 --> 01:00:45,940
表示真实状态的观测结果

1103
01:00:46,090 --> 01:00:49,730
因此 ST是未知的真实状况 OK?

1104
01:00:49,840 --> 01:00:51,890
ST是你不知道的状态

1105
01:00:52,000 --> 01:00:54,130
因为你不能观测到它

1106
01:00:54,280 --> 01:00:56,190
而且 相比之下

1107
01:00:56,380 --> 01:00:59,480
我喜欢使用这些东西 像ST 给定T

1108
01:00:59,630 --> 01:01:04,580
ST+1 给定T 西格玛T给定 T 等等

1109
01:01:04,690 --> 01:01:08,750
这些东西都是你的计算结果 对不对?

1110
01:01:08,860 --> 01:01:14,350
所以 这些东西实际上你计算的东西

1111
01:01:14,420 --> 01:01:15,920
所以 我希望这些符号是OK的

1112
01:01:16,000 --> 01:01:18,480
但这些 - ST是未知真实状态 对吗?

1113
01:01:18,590 --> 01:01:20,760
ST 而这些东西 等于一个给定的T 等等

1114
01:01:20,870 --> 01:01:22,570
这些东西 你在你的算法中计算

1115
01:01:22,680 --> 01:01:23,670
OK?

1116
01:01:23,810 --> 01:01:28,630
所以 预测的步骤是什么

1117
01:01:28,750 --> 01:01:58,740
在更新步骤中 你会发现 - 好 OK?

1118
01:01:58,850 --> 01:03:24,810
因此 那是卡尔曼滤波更新

1119
01:03:24,910 --> 01:03:29,840
你通过Y1到YT 计算你的ST

1120
01:03:29,960 --> 01:03:35,850
所以执行最近的卡尔曼滤波更新之后

1121
01:03:35,960 --> 01:03:38,250
你会发现 对不?

1122
01:03:38,370 --> 01:03:41,080
根据ST+1的估计 你的感知分布

1123
01:03:41,150 --> 01:03:43,440
到目前为止 给定所有观察结果

1124
01:03:43,550 --> 01:03:47,860
鉴于这个均值和

1125
01:03:47,960 --> 01:03:49,220
方差的高斯

1126
01:03:49,330 --> 01:03:51,770
非正式的 因此

1127
01:03:51,880 --> 01:03:55,370
这个东西ST+1

1128
01:03:55,490 --> 01:04:00,890
给定的T+1 ST+1就是我们的最好的估计

1129
01:04:01,000 --> 01:04:09,460
对不?

1130
01:04:09,570 --> 01:04:15,480
考虑到那个时候我们已经有的观察结果

1131
01:04:15,560 --> 01:04:16,310
OK?

1132
01:04:16,430 --> 01:04:19,050
再次 这些方程的正确性 – 的事实

1133
01:04:19,130 --> 01:04:20,870
实际上 我计算这个高斯分布的均值

1134
01:04:20,980 --> 01:04:24,660
和协方差

1135
01:04:24,770 --> 01:04:27,120
你可以--如果你愿意

1136
01:04:27,230 --> 01:04:31,480
你可以在家里证明它 OK?

1137
01:04:31,590 --> 01:04:34,090
实际上 我要把这个与LQR控制放在一起

1138
01:04:34,200 --> 01:04:36,210
但 所以在我做之前 让我检查

1139
01:04:36,320 --> 01:04:38,120
是否有关于这个 有什么问题吗?

1140
01:04:38,270 --> 01:04:41,740
其实让我擦除电路板

1141
01:04:41,850 --> 01:05:27,070
而你看看在这 好的 OK

1142
01:05:27,180 --> 01:05:30,030
卡尔曼滤波器有任何疑问吗?请说

1143
01:05:30,180 --> 01:05:33,370
学生:它是如何计算加强的

1144
01:05:33,440 --> 01:05:38,980
比计算一些绘图高斯分布

1145
01:05:39,090 --> 01:05:41,170
然后找到条件-

1146
01:05:41,280 --> 01:05:44,040
教导员(安德鲁吴):很快 是啊 当然

1147
01:05:44,160 --> 01:05:46,630
那么 这为什么比我刚才讲的

1148
01:05:46,630 --> 01:05:48,580
原始计算方法更集中呢?

1149
01:05:48,650 --> 01:05:51,760
因此 在原来的方法 我谈 - 哇

1150
01:05:51,870 --> 01:05:55,950
这是真的来回

1151
01:05:56,060 --> 01:05:59,130
我说 让我们构建一个Z

1152
01:05:59,250 --> 01:06:01,230
这是这个巨大的高斯的事情 对吗?

1153
01:06:01,380 --> 01:06:09,500
并计算出Z的均值和协方差矩阵是什么

1154
01:06:09,600 --> 01:06:13,560
所以西格玛将是如R - 这将是 - 好

1155
01:06:13,670 --> 01:06:18,210
它是粗糙的 对不?一个T*T的矩阵 对不?

1156
01:06:18,350 --> 01:06:24,030
这实际上是--T*T实际上是T乘以

1157
01:06:24,140 --> 01:06:26,390
状态变量加上

1158
01:06:26,540 --> 01:06:30,200
观测变量的数目

1159
01:06:30,310 --> 01:06:31,760
这是一个巨大的矩阵

1160
01:06:31,830 --> 01:06:34,830
并且随着数量的增加

1161
01:06:34,930 --> 01:06:36,760
西格玛将变得越来越大

1162
01:06:36,870 --> 01:06:42,220
因此 条件和边缘化的业务需要

1163
01:06:42,370 --> 01:06:45,770
计算T的逆和T的子集

1164
01:06:45,880 --> 01:06:49,140
天真的处理方式是

1165
01:06:49,220 --> 01:06:52,490
COS TQ的估算

1166
01:06:52,600 --> 01:06:55,190
如果你做了天真的事情

1167
01:06:55,270 --> 01:06:56,160
如果 - 因为反向的

1168
01:06:56,280 --> 01:06:57,900
T*T矩阵粗糙的COS TQ

1169
01:06:58,010 --> 01:07:01,890
相比之下 卡尔曼滤波算法

1170
01:07:02,000 --> 01:07:04,800
像我在这里说的

1171
01:07:04,910 --> 01:07:06,430
我有更新的步骤 于另外一块黑板上

1172
01:07:06,540 --> 01:07:08,330
我曾预测的步骤

1173
01:07:08,440 --> 01:07:10,330
但是你可以开展

1174
01:07:10,470 --> 01:07:11,950
这两个线的估算

1175
01:07:12,070 --> 01:07:13,630
它实际上是恒定的时间

1176
01:07:13,750 --> 01:07:15,170
因此 在每一个时间步长

1177
01:07:15,290 --> 01:07:17,000
在执行这些卡尔曼滤波更新

1178
01:07:17,110 --> 01:07:19,510
因此 如果你多观察一个数据

1179
01:07:19,620 --> 01:07:21,600
你执行一个卡尔曼滤波更新

1180
01:07:21,710 --> 01:07:25,530
并且计算不依赖于它的 –

1181
01:07:25,610 --> 01:07:27,930
或为每一个时间步长一次

1182
01:07:28,040 --> 01:07:31,910
所以你需要记住东西的数量

1183
01:07:32,030 --> 01:07:34,760
和你看到的时间步长不是线性增长的

1184
01:07:34,870 --> 01:07:36,060
OK?

1185
01:07:36,210 --> 01:07:38,890
因为 - 实际上是什么 –

1186
01:07:39,000 --> 01:07:40,540
我想我才意识到为什么 - 所以 是的

1187
01:07:40,650 --> 01:07:42,760
其实 这是我们实际运行卡尔曼滤波的方式

1188
01:07:42,870 --> 01:07:47,740
那是我最初的观察结果

1189
01:07:47,860 --> 01:07:51,580
所以我然后计算PX1 给定Y1 对不?

1190
01:07:51,690 --> 01:07:53,840
现在我知道为什么我觉得

1191
01:07:53,950 --> 01:07:55,490
我的直升机是在时间步长1

1192
01:07:55,600 --> 01:07:56,520
经过计算

1193
01:07:56,630 --> 01:07:57,730
这有可能有一些时间的推移

1194
01:07:57,840 --> 01:08:00,830
像第二次 然后我得到另一个观测结果

1195
01:08:00,950 --> 01:08:02,830
我会做什么

1196
01:08:02,880 --> 01:08:06,100
我将结合这个两个东西 来计算PX2

1197
01:08:06,210 --> 01:08:09,160
给定Y1和Y2 对不?

1198
01:08:09,270 --> 01:08:11,000
然后可能是另一个第二次传递时间

1199
01:08:11,120 --> 01:08:12,360
我得到另一个观察结果

1200
01:08:12,510 --> 01:08:14,260
所以 我的直升机多一点点移动

1201
01:08:14,370 --> 01:08:15,590
因为另一个第二的通过

1202
01:08:15,700 --> 01:08:17,200
我也得到另一种观测结果

1203
01:08:17,350 --> 01:08:21,710
我要做的就是我结合这两个计算PSV

1204
01:08:21,820 --> 01:08:23,750
给定Y1 Y2 Y3的

1205
01:08:23,860 --> 01:08:26,470
而事实证明 为了计算这个

1206
01:08:26,590 --> 01:08:30,710
我不需要记住这些早期的观测

1207
01:08:30,820 --> 01:08:32,750
OK?

1208
01:08:32,900 --> 01:08:37,050
因此 这是如何在实际中运行的 OK?

1209
01:08:37,160 --> 01:08:43,710
酷 因此  - 哦 讨厌 时间不多了

1210
01:08:43,820 --> 01:08:45,440
我想要做的最后一件事情

1211
01:08:45,550 --> 01:08:47,360
实际上是把这些东西放在一起

1212
01:08:47,510 --> 01:08:48,810
因此 把它在一起 –

1213
01:08:48,930 --> 01:09:00,670
卡尔曼滤波与LQR控制你称为

1214
01:09:00,740 --> 01:09:02,400
LQG控制算法

1215
01:09:02,500 --> 01:09:04,800
线性二次高斯

1216
01:09:04,910 --> 01:09:06,620
但这种类型的控制问题

1217
01:09:06,730 --> 01:09:09,380
我们有一个非线性动力学系统

1218
01:09:09,460 --> 01:09:13,050
因此我现在把动作添加回 对不?

1219
01:09:13,160 --> 01:09:14,180
所以现在B * AT OK?

1220
01:09:24,350 --> 01:09:33,660
然后 使LQG问题

1221
01:09:33,760 --> 01:09:35,520
或线性二次高斯问题

1222
01:09:35,620 --> 01:09:38,080
我有一个非线性动力学系统 我想控制

1223
01:09:38,200 --> 01:09:41,740
我没有得到直接观察状态

1224
01:09:41,850 --> 01:09:45,930
我只得到这些变量YT OK?

1225
01:09:46,080 --> 01:09:49,030
所以我只得到了实际状态观测的噪音

1226
01:09:49,180 --> 01:09:51,490
因此 事实证明

1227
01:09:51,630 --> 01:09:55,970
你可以如下解决LGG控制问题

1228
01:09:56,080 --> 01:09:58,650
在每一个时间步

1229
01:09:58,760 --> 01:10:12,710
我们将使用卡尔曼滤波估计状态 对不?

1230
01:10:12,820 --> 01:10:16,350
所以 具体 - 比方说 你知道初始状态

1231
01:10:16,470 --> 01:10:18,570
然后 你可以初始化成这样的

1232
01:10:18,640 --> 01:10:22,900
如果你知道 初始状态是一些为零的状态

1233
01:10:22,980 --> 01:10:31,660
你初始化为零 或别的状态 对不?

1234
01:10:31,780 --> 01:10:40,600
而这仅仅是 - 好 OK?

1235
01:10:40,680 --> 01:10:41,880
如果你不知道确切的初始状态

1236
01:10:42,030 --> 01:10:44,570
那么这仅仅是初始状态估计的平均值

1237
01:10:44,680 --> 01:10:45,690
这将是你的

1238
01:10:45,770 --> 01:10:46,970
方差或初始状态估计

1239
01:10:47,090 --> 01:10:49,800
所以只要初始化你的卡尔曼滤波成这样

1240
01:10:49,910 --> 01:10:52,010
然后使用每一步的卡尔曼滤波

1241
01:10:52,090 --> 01:10:53,560
来估计状态是什么

1242
01:10:53,640 --> 01:10:57,380
因此 这里的预测步骤 对不?

1243
01:10:57,460 --> 01:11:20,010
以前我们ST+1 给定T 等于 - 等等

1244
01:11:20,120 --> 01:11:21,430
因此 这是你的预测步骤

1245
01:11:21,500 --> 01:11:22,910
然后你有一个更新的步骤 和以前一样

1246
01:11:23,020 --> 01:11:24,890
我要去做出预测步骤的一个改变

1247
01:11:24,990 --> 01:11:28,690
现在我要考虑到这一点

1248
01:11:28,760 --> 01:11:30,930
这是刚刚说假设我以前的状态是

1249
01:11:31,040 --> 01:11:32,330
ST给定T

1250
01:11:32,440 --> 01:11:35,010
我的下一个状态的ST+1给定T

1251
01:11:35,120 --> 01:11:36,940
将不会给予其他的观测结果

1252
01:11:37,010 --> 01:11:38,920
并且答案是 你知道

1253
01:11:39,000 --> 01:11:42,720
它其实是这个方程 AST 给定T+BAT

1254
01:11:42,830 --> 01:11:49,170
那么 这处理了观察结果

1255
01:11:49,280 --> 01:11:54,130
然后你要做的其他的事情

1256
01:11:54,210 --> 01:12:02,480
是使用LQR计算的LT 对不?

1257
01:12:02,550 --> 01:12:10,510
假设 - 然后你要做的其他的事情

1258
01:12:10,620 --> 01:12:12,610
就是你刚才看的非线性动力学系统

1259
01:12:12,730 --> 01:12:14,190
现在先忘记观测结果

1260
01:12:14,270 --> 01:12:18,750
并计算出最佳的政策 - 哦 对了

1261
01:12:18,870 --> 01:12:19,830
在此之前 我们有

1262
01:12:19,900 --> 01:12:24,420
你会选择行动等于LT乘以ST

1263
01:12:24,540 --> 01:12:25,810
对不?

1264
01:12:25,920 --> 01:12:27,850
因此 最优的政策 我们说的是这些矩阵

1265
01:12:27,960 --> 01:12:29,560
LT乘以ST

1266
01:12:29,720 --> 01:12:31,920
因此 这个问题的其他部分

1267
01:12:32,030 --> 01:12:35,260
你会使用LQR计算这些矩阵的LT

1268
01:12:35,370 --> 01:12:37,820
忽略了一个事实 你不观测它的状态

1269
01:12:37,930 --> 01:12:42,760
LQR控制的最后一步是 – 


1270
01:12:42,870 --> 01:12:44,870
当你实际飞行直升机

1271
01:12:44,990 --> 01:12:47,020
当你做 无论你做什么

1272
01:12:47,130 --> 01:12:48,960
你不能观测它的实际状态

1273
01:12:49,080 --> 01:12:50,690
因为在LGG问题中

1274
01:12:50,760 --> 01:12:52,120
你不能精确地观察到它的状态

1275
01:12:52,230 --> 01:12:57,420
所以你所做的是 你实际执行的政策时

1276
01:12:57,570 --> 01:13:00,350
你选择的行动

1277
01:13:00,460 --> 01:13:05,170
根据你的最佳状态估计 OK?

1278
01:13:05,250 --> 01:13:06,640
所以换句话说

1279
01:13:06,750 --> 01:13:08,670
你不知道ST是什么

1280
01:13:08,780 --> 01:13:10,900
但你最好的状态估计 在任何时间

1281
01:13:11,010 --> 01:13:12,430
是这个ST给定T

1282
01:13:12,550 --> 01:13:15,310
所以 你只需将其插入那些

1283
01:13:15,420 --> 01:13:16,580
采取的LT乘以你最好的状态估计

1284
01:13:16,690 --> 01:13:18,470
你继续

1285
01:13:18,590 --> 01:13:21,620
在你的系统上 或者直升机上等等

1286
01:13:21,740 --> 01:13:24,040
执行动作 OK?

1287
01:13:24,160 --> 01:13:27,620
而事实证明 对于这个特定的问题

1288
01:13:27,730 --> 01:13:29,950
其实这是最佳的过程

1289
01:13:30,070 --> 01:13:32,660
这实际上将导致你在

1290
01:13:32,740 --> 01:13:34,640
你的LQG问题上最佳行为

1291
01:13:34,750 --> 01:13:38,140
而有这种直觉

1292
01:13:38,250 --> 01:13:41,710
合刚才我说的LQR问题几乎一样

1293
01:13:41,790 --> 01:13:43,040
如果噪声没有影响

1294
01:13:43,130 --> 01:13:46,180
并在一个纯粹的LQR问题中 WT项并不重要

1295
01:13:46,260 --> 01:13:47,720
这是因为你可以忽略的噪音

1296
01:13:47,840 --> 01:13:50,530
因此 原来通过阐述那个证明

1297
01:13:50,640 --> 01:13:52,250
我不会去证明 你可以 –

1298
01:13:52,330 --> 01:13:56,440
欢迎您在家中自己证明

1299
01:13:56,520 --> 01:13:57,870
直觉是 这实际上意味着你可以忽略

1300
01:13:57,950 --> 01:13:59,170
在你的观察中的噪声

1301
01:13:59,260 --> 01:14:01,070
给予T ST是你的最佳估计

1302
01:14:01,180 --> 01:14:06,870
因此 如果您的真实状态

1303
01:14:06,970 --> 01:14:13,140
ST 等于 ST 给定T加上噪声

1304
01:14:13,250 --> 01:14:15,640
因此在LQG控制中

1305
01:14:15,710 --> 01:14:17,190
我们将要做的事是忽略的噪音

1306
01:14:17,300 --> 01:14:19,270
并且只需用上给定T的ST

1307
01:14:19,340 --> 01:14:21,780
这原来最佳的事情

1308
01:14:21,890 --> 01:14:24,260
我应该说 这原来是

1309
01:14:24,410 --> 01:14:26,940
一个非常特殊的情况下的一个问题

1310
01:14:27,090 --> 01:14:29,830
在这里你可以忽略的噪音

1311
01:14:29,930 --> 01:14:33,770
仍然最佳行为 并且属性 –

1312
01:14:33,880 --> 01:14:36,960
这实际上是所谓的相分离的原则

1313
01:14:37,070 --> 01:14:40,830
在这里您可以设计一个算法估计状态

1314
01:14:40,980 --> 01:14:42,600
并设计一个用于控制系统的算法

1315
01:14:42,710 --> 01:14:44,800
所以只是把两者结合起来

1316
01:14:44,920 --> 01:14:46,370
真可谓是最佳

1317
01:14:46,440 --> 01:14:47,780
这是一个非常不寻常的属性

1318
01:14:47,880 --> 01:14:50,140
并且它只对于LQG是正确的

1319
01:14:50,260 --> 01:14:52,340
对于很多许多系统 它不成立

1320
01:14:52,450 --> 01:14:53,590
一旦你改变什么

1321
01:14:53,700 --> 01:14:56,910
一个人的非线形的 你知道 一些其他噪音

1322
01:14:57,020 --> 01:14:59,890
一旦这种非线形模型 - 我不知道

1323
01:15:00,000 --> 01:15:01,480
一旦你改变在这个问题上几乎所有的东西

1324
01:15:01,630 --> 01:15:03,040
这将不再适用

1325
01:15:03,190 --> 01:15:04,720
-只是估计状态

1326
01:15:04,830 --> 01:15:06,700
并且进入设计的控制器

1327
01:15:06,820 --> 01:15:08,380
假设你可以完全观察它的状态

1328
01:15:08,490 --> 01:15:12,090
但是 一旦你改变几乎任何的东西

1329
01:15:12,170 --> 01:15:13,980
这将不再成为最优的

1330
01:15:14,090 --> 01:15:16,110
但对于具体的LQG问题

1331
01:15:16,220 --> 01:15:17,720
它是一种方便 你可以这样做

1332
01:15:17,830 --> 01:15:19,910
一个快速的问题 之后我们就结束吧

1333
01:15:20,010 --> 01:15:23,470
学生:[听不清]

1334
01:15:23,550 --> 01:15:24,630
教导员(安德鲁吴):噢 是的 是啊

1335
01:15:24,740 --> 01:15:26,060
在每一个大使飞行中--

1336
01:15:26,160 --> 01:15:27,650
我描述的我的一切

1337
01:15:27,760 --> 01:15:29,250
我假设你已经学过A和B

1338
01:15:29,330 --> 01:15:30,980
或其他东西 所以--

1339
01:15:31,080 --> 01:15:32,700
学生:[听不清]

1340
01:15:32,810 --> 01:15:33,860
教导员(安德鲁吴):是的 正确的 OK

1341
01:15:33,960 --> 01:15:35,240
很抱歉 我们今天有点晚了

1342
01:15:35,350 --> 01:15:36,330
让我们今天结束

1343
01:15:36,330 --> 01:15:37,680
下一次我将多讨论点这些

1344
01:15:37,760 --> 01:15:39,180
部分的观测问题

